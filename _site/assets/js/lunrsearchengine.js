
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": " 404:  It seems we've run into some issues. Let's go home? "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "About C. Wu",
    "body": "追求使用者體驗的前端工程師。 熟悉JavaScript ES2015+、TypeScript 與 Angular 9。 Who's C?: I am a front-end developer and a UI/UX designer currently based in Taipei, Taiwan. Commonly referred to by friends and colleagues as Lily, I am passionate about weaving pixel-perfect visuals and clean code together to turn them into practical solutions.  When I am not coding or designing, you can usually find me shooting portrait photography, diving into another new JavaScript framework just for fun or walking around with a cup of tea on a sunny day. resume "
    }, {
    "id": 2,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "   Featured:                                                                                                                                                                                                   Bidirectional data flow in React                              :               短篇 React 學習筆記: 使用 React Hooks 讓 React 能像 Angular 一樣做出 two-way data flow 的效果。:                                                                                                                                                                                                                                             React 跟 Angular 的框架分析 — Part 3: 兩個框架的優缺點                              :               歡迎再度回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                                                                                                                                                                             React 跟 Angular 的框架分析 — Part 2: 框架趨勢                              :               歡迎回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                                                                                                                                                                                 React 跟 Angular 的框架分析 — Part 1: Angular 跟 React 的快速背景                              :               歡迎來到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                                                                                                                                                                                                                         前端也可以寫手機 app ? 神奇的框架: NativeScript                              :               「魔鏡啊，魔鏡，什麼東西可以讓我寫一次就產生蘋果和安卓的 app？」:                                                                                                                                                                                                                                             今年黑五不購物，讀書去~                              :               那個去年黑五在打LoL、吃牛排的 Angular 工程師，今年怎麼開始學 React. js 啦？:                                                   All Stories:                                                                                       Bidirectional data flow in React              :       短篇 React 學習筆記: 使用 React Hooks 讓 React 能像 Angular 一樣做出 two-way data flow 的效果。:                                                                                           React 跟 Angular 的框架分析 — Part 3: 兩個框架的優缺點              :       歡迎再度回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                           React 跟 Angular 的框架分析 — Part 2: 框架趨勢              :       歡迎回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                           學習筆記：Angular 特色              :       學習筆記之Angular特色記載篇！！:                                                                                           React 跟 Angular 的框架分析 — Part 1: Angular 跟 React 的快速背景              :       歡迎來到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                           Build Custom Hooks              :       短篇 React 學習筆記。:                                                                                           Conditional Rendering              :       短篇 React 學習筆記。:                                                                                           Event Handling              :       短篇 React 學習筆記。:                                                                                           useEffect Hooks              :       短篇 React 學習筆記。:                &laquo; Prev    1    2    Next &raquo;  "
    }, {
    "id": 4,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %}  {% if post. featured == true %}  {% include featuredbox. html %}  {% endif %}  {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %}  {% include postbox. html %}  {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 6,
    "url": "http://localhost:4000/react-12/",
    "title": "Bidirectional data flow in React",
    "body": "2021/01/05 - 短篇 React 學習筆記: 使用 React Hooks 讓 React 能像 Angular 一樣做出 two-way data flow 的效果。 coming soon！ "
    }, {
    "id": 7,
    "url": "http://localhost:4000/react-vs-angular-part-3/",
    "title": "React 跟 Angular 的框架分析 — Part 3: 兩個框架的優缺點",
    "body": "2020/12/31 - 歡迎再度回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！ 這篇分析會切成以下四個部分，你現在在這裡： Angular 跟 React 的快速背景快速帶過近幾年兩個框架的發展 trends （更詳細的 trends 分析會另外開一篇）兩個框架的優缺點，每提一點，會附上實作 comparison下集預告：配合後端 + 串起 API 後，誰勝出準備好的話，我們就開始囉~ 框架優缺點: 如果可以拿食物來形容兩個框架的話，React 是單點套餐，可以一直加不同的配餐，而 Angular 就是全家桶一次給你、給你、都給你。 一切取決於你想要什麼東西。 但是，嘰裡呱啦講了那麼多，我們怎麼知道誰比較好？ 簡單，寫出來就知道了！ 接來下，我們拿 Todo List 當例子，把這個範例用 Angular 跟 React 各寫一次。 並在寫 code 時分析並提出兩個框架的優劣處。 框架結構: 首先我們來理解一下 Angular 的結構Angular 是採 MVC 方式，也就是說一個 component 上面，你會有 4 個檔案：  TypeScript：component 邏輯 css/scss: 如名 style 檔案 HTML: 呈現的網頁 spec. ts: 測試檔在 TypeScript 檔案裡面寫好你的 class，html 顯示你的 template，scss 呈現 style，最後用 spec 來測試。 而 React 在資料結構上，就乾淨簡潔的許多 如果採用 JSX 的話， React 就只有一個 JSX 檔。 而我們之前提過 React 採取了 Virtual DOM 的方式，用 JSX 寫法的話，我們可以選擇要寫 class component 或是 functional component。 近幾年，因為 React Hooks 的崛起，functional 開始被重用，而 loading 的速度也更快了。 要測試 React 的話，跟 Angular 一樣 React 需要額外寫測試檔，但不一定每個 component 都要單獨寫一個！ React 個人小偏好 在 React 的資料夾結構上，我個人偏好是這樣： components:  Book     index. js   Book. jsx   把寫好的 component 分裝進一個專屬的資料夾，裡面有 index. js 跟 component 的 jsx 檔案。 在將 index. js 輸出 component，方便其他頁面讀取。 看完了結構，我們來聊聊撰寫時的便利度！ 接下來的部分重寫中，上次舉的例子沒有特別好，所以還請各位客官見諒，他很快就會被補回來的！ "
    }, {
    "id": 8,
    "url": "http://localhost:4000/react-vs-angular-part-2/",
    "title": "React 跟 Angular 的框架分析 — Part 2: 框架趨勢",
    "body": "2020/12/29 - 歡迎回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！ 這篇分析會切成以下四個部分，你現在在這裡： Angular 跟 React 的快速背景快速帶過近幾年兩個框架的發展 trends （更詳細的 trends 分析會另外開一篇）兩個框架的優缺點，每提一點，會附上實作 comparison下集預告：配合後端 + 串起 API 後，誰勝出準備好的話，我們就開始囉~ 框架趨勢: 崛起的 React: 雖然 React 在 2013 正式發佈，但是根據各大網站分析 React 還是壟斷了市場。 我們來看一些 React vs Angular 的數據圖： 每年的下載數據： 過去兩年的下載數據 (2018-2020, NPMTrends. com)： 過去 5 年，在 Google Trends 上大家都在搜尋的框架 (2015-2020)： 這三張數據圖，都可以看到 React 已經稱霸前端框架了。 可是 Angular 不是比 React 早出來嗎？這是怎麼一回事？ 這裡我們要講到 Angular 的一段小歷史。 哭泣的 Angular: 上一篇有提到，其實大家很容易搞混 AngularJS 跟 Angular 2+。 我們來回顧下： AngularJS = 2010 年就推出的舊框架，明年即將被 Google 冷藏，不再支援。 Angular 2+ （又或是我們在市場常看的 Angular 7, Angular 8… Angular 11 等） = 2016 年才推出的框架，是 AngularJS 的升級版。 功能比 AngularJS 強大，但是還是很多人容易誤會，以為 Angular 2 = AngularJS。 也可以說 Angular 2+ 無辜被前輩 AngularJS 陷害，讓大家以為他還是很難用。 另外，我們現在 2020 年，公司一般如果提到 Angular，其實都是在說 Angular 2+，基本上已經沒有人在用 AngularJS 了。 但還是有很多人不明白，以為市場上說的 Angular 是 AngularJS。 而在這篇文章裡，我如果提到 Angular，就是在說 Angular 2+。 更新速度: 講完了兩個框架的趨勢已經釐清了小誤會，我們來聊一下框架版本的更新速度。 拿 Angular 來講，Angular 的官網表示每半年就會出一個 major release，每個 major release 都會被 Angular 支援 18 個月（半年 active support，一年 LTS）。 換句話說就是 Angular 工程師們有差不多半年的時間可以快速學習該版本的更新，學完後就要繼續迎接更新版本的 updates。 而 React 每個版本差不多是一年大更新一次，近幾年來最重大的是 React 16. 8，帶來了 React 未來的趨勢– Hooks! (這個我們接下來再細聊) 那我們再來看看 StackOverflow 上面的數據： 2020 年 StackOverflow 上，工程師最愛框架統計問卷: 我們一比之下，React 佔了快 7 成的前端市場，緊追在後的是近幾年崛起的 Vue. js（這個有機會我們再聊）。 而我們的 Angular ，雖然近幾年在前端沒有比 React 那麼吃香，但也佔據了 5 成。 而大家常常搞混的 AngularJS （ Angular的前身 ）只佔了 24 %，而且還榮登大家最討厭的框架之一： 2020 年 StackOverflow 上，工程師最恨框架統計問卷: 其實 Angular 跟 React 只差了 10% 而已，所以我們也可以說 Angular 其實是被 AngularJS 害慘了（因為大家常常分不清楚他們兩個）。 那都說 React 比 Angular 好，那他到底好在哪裡？ 我們看下去！ 下集預告：框架優缺點…: 市場趨勢講完了，我們終於要進入重頭戲框架優缺點，以及非常刺激的大對比。 沒錯，接下來我會以以往寫過不同案子的功能舉例，同時撰寫 Angular + React 並分析他們的優缺點！ 我們下次見，掰掰~ "
    }, {
    "id": 9,
    "url": "http://localhost:4000/angular-highlight/",
    "title": "學習筆記：Angular 特色",
    "body": "2020/12/29 - 學習筆記之Angular特色記載篇！！ Angular 特色: Angular 是 2016 年被推出的框架，一樣是 Google 開發的，可是兩者基本上是 Java 跟 JavaScript 的差別，基本上兩個不同的語言。 Angular 採用 JS ES6 來開發，它主要由 8 個部分組成： 模塊 (Modules)組件 (Components)模板 (Templates)元數據 (Metadata)數據綁定 (Data Binding)指令 (Directives)服務 (Services)依賴注入 (Dependency Injection)1. 模塊 (Modules) 模塊，如名由一塊塊代碼組成，用來執行簡單任務。 Angular 是模塊化的，有自己的模塊系統：NgModules。 而每個 Angular 專案至少要有一個模塊(根模塊，所謂的 Root Module)，一般為：AppModule。 Angular 模塊是一個帶有 @NgModule 裝飾器的類，它接收一個用來描述模塊屬性的元數據對象。 範例： 12345678910111213141516import { NgModule } from'@angular/core';import { BrowserModule } from'@angular/platform-browser';@NgModule( {imports: [BrowserModule], providers: [Logger], declarations: [AppComponent], exports: [AppComponent], bootstrap: [AppComponent] }) export class AppModule {}NgModule 裡面的屬性我就不一一講解了。 創建完 AppModule 後，通過導入根模塊來啟動我們的專案，開發過程通常在 main. ts 裡面來 import AppModule。 範例： 123456import { platformBrowserDynamic } from'@angular/platform-browser-dynamic';import { AppModule } from'. /app. module';platformBrowserDynamic(). bootstrapModule(AppModule);2. 組件(Components) Angular 核心，用來處理應用和邏輯頁面的 view，可用於整個專案。 要創建 Component ，我們得從 @angular/core 中引入 Component 修飾器 12345678@Component({ selector:  'app-hero-list', templateUrl: '. /hero-list. component. html', providers: [ HeroService ]})export class HeroListComponent implements OnInit {/* . . . */}3. 模板 (Templates) 模板 = HTML view 透過 component 裡面的 templateUrl 即可告知 Angular 如何顯示組件。 1&lt;div&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/div&gt;4. 元數據 (Metadata) Metadata 其實就是 Angular 用來將 class 定義成 component 的資訊。 範例： 1234567@Component({ selector:  'app-hero-list', templateUrl: '. /hero-list. component. html', providers: [ HeroService ]})export class HeroListComponent implements OnInit {/* . . . */5. 數據綁定 (Data Binding) 管理應用程式裡面數值的一種機制，可以從HTML裡面取值和賦值，使得數據的讀寫，數據的持久化操作變得更加簡單快捷。 Angular 則有四種 data binding 模式。 每種形式都有自己的一個方向：從 DOM 來、到 DOM 去、雙向 我們看張圖： 插值: 在 HTML 中顯示組件值。 123&lt;h3&gt;&lt;/h3&gt;&lt;img src=  &gt;屬性綁定: 把元素的屬性設置為組件中屬性的值。 1&lt;img [src]= userImageUrl &gt;事件綁定: 在組件方法名被點擊時觸發。 1&lt;button (click)= onSave() &gt;save&lt;/button&gt;雙向綁: 使用 Angular 里的 NgModel 指令進行雙向綁定。 12&lt;input [value]= currentUser. firstName (input)= currentUser. firstName=$event. target. value  &gt;6. 指令 (Directives) 當 Angular 渲染模板時，它會根據指令對 DOM 進行修改。 Angular 有三種類型的 directives:  屬性指令：以元素的屬性形式來使用的指令。 結構指令：用來改變DOM樹的結構 組件：作為指令的一個重要子類，組件本質上可以看作是一個帶有模板的指令。範例： 123&lt;li *ngFor= let book of books &gt;&lt;/li&gt;&lt;book-info *ngIf= selectedBook &gt;&lt;/book-info&gt;*ngFor 告訴 Angular 為 books 列表中的每個項生成一個 &lt;li&gt; 標籤。 *ngIf 表示只有在 selectedBook 等於 true 時，才會包含 book-info 組件。 7. 服務 (Services) 服務是封裝了某一特定功能，並且可以通過注入的方式讓人使用的獨立模塊。 服務有內建，也可自己撰寫。 一個 service 的範例 12345678910export class BookListService { AddBook(book: BookModel) { console. log('added book:'${book}); } EditBook(book: BookModel) { console. warn('edited book:'${book}); } DeleteBook(book: BookModel) { console. error('deleted book:'${book}); }}8. 依賴注入 (Dependency Injection) 因為 DI 本身有太多可以講，故我們這邊就只提到 Service 的 DI。 拿 Service 來說。 123456import { Injectable } from '@angular/core';@Injectable()export class HeroService { constructor() { }}@Injectable()是angular的service使用做依賴注入的裝飾詞，可以使Service成為可被注入的元件。 當我們在provider設定這個服務給這個module使用，如下： 123providers: [ UserService],接著我們就可以在整個專案中從constructor直接宣告這個服務，在所有地方取得的都會是同一個 service。 1234567export class HeroListComponent { heroes: Hero[];  constructor(heroService: HeroService) {  this. heroes = heroService. getHeroes(); }}當然還有很多功能，區區一小篇 blog post 講不完。 就請各位至 Angular 官網慢慢啃食囉~ "
    }, {
    "id": 10,
    "url": "http://localhost:4000/react-vs-angular-part-1/",
    "title": "React 跟 Angular 的框架分析 — Part 1: Angular 跟 React 的快速背景",
    "body": "2020/12/24 - 歡迎來到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！ 這篇分析會切成以下四個部分，你現在在這裡： Angular 跟 React 的快速背景快速帶過近幾年兩個框架的發展 trends （更詳細的 trends 分析會另外開一篇）兩個框架的優缺點，每提一點，會附上實作 comparison下集預告：配合後端 + 串起 API 後，誰勝出準備好的話，我們就開始囉~ 關於 Angular 跟 React: 我們先來聊聊 Angular。 Angular，後面有 Google 爸爸撐腰的 JavaScript 框架。 講到了 Angular 就必須聊聊 Angular 的前身： AngularJS AngularJS: 最早之前 Google 在 2010 年創建了 AngularJS （Angular 的前身），學習難度不低，但當時的確引發了很多話題。 它最大賣點是可以透過 &lt;script&gt; 標籤添加到 HTML 頁面，AngularJS 通過這個指令擴展了HTML，並且通過表達式綁定數據到 HTML。 而最大的特性則是：MVC、模塊化、自動化雙向數據綁定、語義化標籤、依賴注入等等。 那為什麼我們要提到 AngularJS 咧？因為大家很容易搞混 AngularJS 跟 Angular 2+。 AngularJS = 2010 年推出的舊框架，明年即將被 Google 冷藏，不再支援。 Angular 2+ （又或是我們在市場常看的 Angular 7, Angular 8… Angular 11 等） = 2016 年才推出的框架，是 AngularJS 的升級版。 記住我們現在常常聽到的 Angular 7/Angular 8/ Angular 9 什麼的其實都是 Angular 2+ (第二代 Angular)，也是我們的主角。 而在這篇文章裡，我如果提到 Angular，就是在說 Angular 2+。 Angular + 特色: Angular 是 2016 年被推出的框架，一樣是 Google 開發的，可是兩者基本上是 Java 跟 JavaScript 的差別，基本上兩個不同的語言。 Angular 採用 JS ES6 來開發，它主要由 8 個部分組成： 模塊 (Modules)組件 (Components)模板 (Templates)元數據 (Metadata)數據綁定 (Data Binding)指令 (Directives)服務 (Services)依賴注入 (Dependency Injection)對這些部分有興趣的客官們，請移駕至這裡：Angular 特色~ 這邊我們就不一一帶過了，畢竟這篇是在講 React 跟 Angular 的快速歷史。 React 部分重整中，待補上。 下集預告：關於市場趨勢…: 兩個前端框架歷史介紹的差不多了，那他們的市場趨勢又是如何呢？ 誰佔上風？誰比較好上手？又是誰默默崛起、誰被誤會？ 我們下次見~ "
    }, {
    "id": 11,
    "url": "http://localhost:4000/react-11/",
    "title": "Build Custom Hooks",
    "body": "2020/12/21 - 短篇 React 學習筆記。 What is React Hooks?: They are functions that let us hooks into React state and lifecycle features from function components. Hooks reduces the complexity of state management. Redux is great for state management, but there are many steps in the process. Rather, hooks can be seen as a singular step. (More on this in a later post~) Why build our own custom hooks? Building our own hooks lets us extract component logic into reusable functions. Sometimes, when we want to share logic between 2 JavaScript functions, we extract it to a third function. Since hooks and components are JS function, we can extract them as well. Building Custom Hooks: A custom Hook is a JavaScript function whose name starts with “use” and that may call other Hooks. Say we want to to see if our friends are online. But we also want to build a contact list that shows us who is online. So we can extract hook logic, and apply the hook into where the application needs the “friend status” logic. Here’s our custom hook that shows if a friend is online: 123456789101112131415161718import { useState, useEffect } from 'react';function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; {  function handleStatusChange(status) {   setIsOnline(status. isOnline);  }  ChatAPI. subscribeToFriendStatus(friendID, handleStatusChange);  return () =&gt; {   ChatAPI. unsubscribeFromFriendStatus(friendID, handleStatusChange);  }; }); return isOnline;}Now, say we want both Friend Status and Contact List to have the “friend status” logic. That would be… 12345678function FriendStatus(props) { const isOnline = useFriendStatus(props. friend. id); if (isOnline === null) {  return 'Loading. . . '; } return isOnline ? 'Online' : 'Offline';}and contact list… 123456789function ContactListItem(props) { const isOnline = useFriendStatus(props. friend. id); return (  &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;   {props. friend. name}  &lt;/li&gt; );}Keep in Mind…  We must use the prefix “use” in front of our hooks, so it doesn’t get confusing.  The states grabbed by hooks are completely isolated from one another. This means they don’t share the same state.  Each call to a Hook gets isolated state. "
    }, {
    "id": 12,
    "url": "http://localhost:4000/react-10/",
    "title": "Conditional Rendering",
    "body": "2020/12/20 - 短篇 React 學習筆記。 Conditional Rendering: Conditional Rendering = make things happen with certain conditions Common ways in React are…  If. . else statement Element variables Ternary operators Logical &amp;&amp; operators Prevent rendering with nullIf…else: 12345if(isLoggedIn) { return &lt;button&gt; Logout &lt;/button&gt;} else { return &lt;button&gt; Login &lt;/button&gt;}Element Variables: 123456789if(isLoggedIn) { Button = &lt;button&gt; Logout &lt;/button&gt;;} else { Button = &lt;button&gt; Login &lt;/button&gt;;}return( &lt;div&gt;{ Button }&lt;/div&gt;);Ternary operators: 1234567&lt;div&gt; {  isLoggedIn ?    &lt;button&gt; Logout &lt;/button&gt; :   &lt;button&gt; Login &lt;/button&gt; }&lt;/div&gt;Logical &amp;&amp; operators: 12345678&lt;div&gt; {  isLoggedIn &amp;&amp; &lt;button&gt; Logout &lt;/button&gt; } {  !isLoggedIn &amp;&amp; &lt;button&gt; Login &lt;/button&gt; }&lt;/div&gt;Prevent rendering with null: 12345if(isLoggedIn) { return &lt;button&gt; Logout &lt;/button&gt;} else { return null;}"
    }, {
    "id": 13,
    "url": "http://localhost:4000/react-09/",
    "title": "Event Handling",
    "body": "2020/12/20 - 短篇 React 學習筆記。 Handling Events: Events are fired when user interacts with the application. Some examples in React are…  onclick onchange onfocus onblurHandling events in React is very similar to handling events in DOM elements. But there are still some differences… Example of event handling in functional component: 1234567891011function FunctionEventHandling() { function handleClick(e){  console. log('I am eating!!'); } return (  &lt;div&gt;   &lt;button onClick={handleClick}&gt;Let's Eat!&lt;/button&gt;  &lt;/div&gt; );}But why is it this: 1&lt;button onClick={handleClick}&gt;Let's Eat!&lt;/button&gt;and not this? 1&lt;button onClick={handleClick()}&gt;Let's Eat!&lt;/button&gt;Bc the event handling function should NOT be called with (). It we call the handler with (), the function will be executed before the button is clicked!! Event handler is a function not a function call! Example of event handling in class component: 1234567891011121314151617181920212223242526class EatingToggle extends React. Component { constructor(props){  super(props);  this. state = {   isEating: true  };  this. handleClick = this. handleClick. bind(this); } handleClick(){  this. setState( state =&gt; {   isEating: !state. isEating  }) } render(){  return (   &lt;div&gt;    &lt;button onClick={this. handleClick}&gt;     {this. state. isEating ? 'I am eating lah!' : 'Nope, not eating'}     &lt;/button&gt;   &lt;/div&gt;  ); }}` "
    }, {
    "id": 14,
    "url": "http://localhost:4000/react-08/",
    "title": "useEffect Hooks",
    "body": "2020/12/19 - 短篇 React 學習筆記。 useEffect Hooks: Use this Hook to tell React what to do when the component needs to perform a task after rendering. Sample: This side effect will execute on every render including when the component has mounted and every time it updates. Let’s use fetch user from an API as an example…: componentDidMount() 12345678useEffect(() =&gt; { // componentDidMount code goes here fetchUserApi(id). then((user) =&gt; {   setUser(user) })}, []);^Bc we passed an empty array as the second parameter, the useEffect hook will only execute once. componentDidUpdate(prevProps) 1234567useEffect(() =&gt; { // ComponentDidUpdate code goes here  fetchUserApi(id). then((user) =&gt; {   setUser(user) })}, [id]);^This effect will execute only once, when component is updated (includes re-rendering). componentWillUnmount() 123456useEffect(() =&gt; { return() =&gt; {  // componentWillUnmount code goes here  setUser(null) }}, []);All Three Combined 12345678910useEffect(() =&gt; { fetchUserApi(id). then((user) =&gt; {   setUser(user) }) return() =&gt; {  setUser(null) }}, [id]);"
    }, {
    "id": 15,
    "url": "http://localhost:4000/react-07/",
    "title": "Component Lifecycle",
    "body": "2020/12/19 - 短篇 React 學習筆記。 現在一大部分已被 useEffect Hook 取代，但是還是很有學習價值。 Component Lifecycle: In each component, React has a lifecycle which you can monitor and manipulate during its 3 main phases.  ComponentWillMount():  Called once in its component’s lifecycle Called before component render() Avoid any asynchronous behavior in this method setState won’t cause a re-renderComponentDidMount():  Called after component render() once Async function can be called here Call setState here for re-renderComponentWillUnmount():  Called right before component is removed from the DOM Performs cleanups here. (i. e. cancel network call)ComponentWillUpdate():  Lets you manipulate component just before receiving new state/props. ComponentDidUpdate():  Called after any rendered HTML has finished loading. "
    }, {
    "id": 16,
    "url": "http://localhost:4000/react-06/",
    "title": "State",
    "body": "2020/12/19 - 短篇 React 學習筆記。 State: What is State Object that holds information that might change over the lifetime of the component. Used to track data from form input, dynamic data and API. Example - Local State: Assignment: 12345678class Welcome extends React. component { constructor(props){  super(props);  this. state = {   name: 'Boop';  } }}We assign the initial state in the constructor. Reading State: 1console. log(this. state. name);Updating State: 12345// wrongthis. state. name = 'Foo';// correctthis. setState({name: 'Foo'});We need to replace the entire state object. Updating State: State updates may be asynchronous and are merged. Take a look: 123456this. state = { count: 0;}this. setState({count: count + 1}); // count: 1this. setState({count: count + 1}); // count: 1It should give you 2 right?No Both the setState count here is enqueued when its value is 0. So what do we do if we want to access previous state? We pass a function in setState that takes the previous state and updates it in a synchronous manner. Like this: 1234567891011121314151617181920212223this. state = { count: 0;}this. setState( (prevState) =&gt; {  return {   count: prevState. count + 1  } });// count: 1this. setState( (prevState) =&gt; {  return {   count: prevState. count + 1  } });// count: 2useState Hooks (React 16. 8): **To be further discussed in details in a separate post Example code with functional component: 12345678910111213import React, { useState } from 'react';export default function Welcome () { const [count, useCount] = useState(0); return (  &lt;div&gt;   Counter: { count } &lt;br /&gt;   &lt;button onClick={()=&gt; useCount( count + 1 )}&gt;   Add Count&lt;/button&gt;  &lt;/div&gt; );}Note:Hooks aren’t supported in class comp. "
    }, {
    "id": 17,
    "url": "http://localhost:4000/react-05/",
    "title": "Functional Components vs Class Components",
    "body": "2020/12/18 - 短篇 React 學習筆記。 About Components: Core building blocks of React. Multiple individual components forms a parent component. 2 types of components in React:  Functional Class Before React Hooks were introduced, functional components were generally used for style (aka the dumb/stateless/presentational component) and class components were used for logic (smart component/stateful/container components). This practice has since been deprecated. Functional Components: After React Hooks are introduced, functional components are used to store state using react hooks. Like the name implies, think of functional component as a function. Example: 123function Welcome(props) {return &lt;h1&gt;Hello, {props. name} &lt;/h1&gt;;}1const element = &lt;Welcome name= Boop  /&gt; Props should never be modified! When should you use functional components?: For React &lt; 16. 8…  When your comp. simply receive props, doesn’t have a state and renders smth (dumb/stateless/presentational comp. )For React &gt; 16. 8… (React Hooks were introduced)  Func. comp. can now have its own state via React Hooks Preferred over class comp. bc of React Hooks now. Class Components: Class components were preferred before React Hooks were introduced. Basically ES6 classes. Similar to functional component, class comp. optionally receives props as input and renders JSX. Class comp. can also maintain private internal state of a particular comp. Example: 12345class Welcome extends React. Component { render(){  return &lt;h1&gt;Hello, {this. props. name} &lt;/h1&gt;; }}Comp. should always start with capital letter. Again, props should never be modified! Drawbacks:  Class comp. is slower than fun. comp in terms of performance. This difference increases as the number of comp in the app increases.  Slightly inefficient to use bc it requires more coding. "
    }, {
    "id": 18,
    "url": "http://localhost:4000/react-04/",
    "title": "Virtual DOM & DOM Manipulation",
    "body": "2020/12/18 - 短篇 React 學習筆記。 Virtual DOM: React creates a tree of custom objects, each representing a part of the DOM. If we create a p element inside a div, React will create React. div object and React. p object. React will then modify these objects quickly when needed (modifying only what’s required) rather than changing the real DOM. Before it renders the component, React will determine what needs to be changed using the virtual DOM. Then React will get virtual DOM and real DOM in sync. Virtual DOM = blueprint Virtual DOM contains the required details needed to construct the DOM. But it doesn’t require all the heavy parts of the real DOM. Thus, making virtual DOM creation much faster than actual DOM. DOM Manipulation: DOM Manipulation = dynamically changing the content of web page. Reconciliation = changes made to the virtual DOM and then sync to the real DOM. Diffing = process when React figures out which objects has been changed Process:  React updates virtual DOM States of virtual DOM will be compared (previous + updated), to identify what has been changed. This is done via Diffing Algorithm.  Changed objects will get updated to the real DOMExample of Diffing Algorithm: When root is changed, React will delete the tree and rebuild the entire tree. 12345// old&lt;div&gt;&lt;App /&gt;&lt;/div&gt;// new&lt;span&gt;&lt;App /&gt;&lt;/span&gt;When attribute is changed, React will only change the attribute. 12345// old&lt;div id= root &gt;&lt;/div&gt;// new&lt;div id= boop &gt;&lt;/div&gt;When new child element is added at the end of a list, React will simply add it to the list. 123456789101112// old&lt;ul&gt; &lt;li&gt;hi&lt;/li&gt; &lt;li&gt;hi1&lt;/li&gt;&lt;/ul&gt;// new&lt;ul&gt; &lt;li&gt;hi&lt;/li&gt; &lt;li&gt;hi1&lt;/li&gt; &lt;li&gt;hi2&lt;/li&gt;&lt;/ul&gt;"
    }, {
    "id": 19,
    "url": "http://localhost:4000/react-03/",
    "title": "JSX",
    "body": "2020/12/18 - 短篇 React 學習筆記。 JSX: JSX = JavaScript Syntax Extension Lets XML/HTML + JavaScript/React code coexist. Example: 12345const name = 'Boop';const element = '&lt;div&gt;Hello, {name}&lt;/div&gt;';ReactDOM. render(element, document. getElementById('root'));In this example, the variable name is wrapped in JSX. These code are then converted into standard JavaScript objects that can be parsed by the JS Engine. Why JSX?:  Much faster than normal JS, as JSX optimizes when it’s converted into regular JS.  Easy to create template.  React Component lets us keep both markup and logic together in one file using JSX. Attributes in JSX: React DOM uses camelCase. For example, class becomes className… 1let button = &lt;button className= btn-primary &gt;Button&lt;/button&gt;;"
    }, {
    "id": 20,
    "url": "http://localhost:4000/react-02/",
    "title": "ES6",
    "body": "2020/12/17 - 短篇 React 學習筆記。 ES6 for React: JavaScript = a “dialect” of ECMAScript ES6 = ECMAScript 2015 = JavaScript standard. React uses ES6. ES6 is also getting popularity for writing server applications and services via Node. js. Variables: In ES6, variables are declared using const, let and var keywords. We cannot redeclare const or let variables. And, we can only reassign let variable. Block Scope vs Function Scope: var is function scoped. It can be accessed everywhere. let is a block scoped. It can only be accessed inside the block where it is defined. New Update: Arrow Function &amp; Regular Function: Regular Function 123var hello = function(name) {  return name}ES6 Arrow function 1let hello = (name) =&gt; { return name }Even more ways to define arrow functions… We can omit {}, if there’s only one expression 1let hello = (num1, num2) =&gt; num1 + num2;We can omit (), if there’s only one argument 1let hello = name =&gt; name;We can use _, if there’s no argument 1let hello = _ =&gt; 1 + 2;this keyword: In regular function, the this keyword represents the object called inside a function. In arrow function, the this keyword represents the object that defined the function, which is the window. object. Template Literals: Quoted between ``, string literals that can include expressions. Like this… 12let name = 'Boop';let greeting = `Hello, ${name}`;Destructuring: Arrays: 12let array = [1,2,3,4,5];let [value1,value2,value3] = array;this is equivalent to 1234let array = [1,2,3,4,5];let value1 = array[0];let value2 = array[1];let value3 = array[2];Destructuring: Objects: Similar to destructuring array… 123456let obj = { key1: 'boop', key2: 'foo', key3: 'bar'};let [key1,key2,key3] = obj;Spread Operator: The spread operator spreads the values in an iterable, such as array &amp; strings, across arguments or elements. 123456let fruits = ['apples','bananas','strawberry'];let veggies = ['cabbage','asparagus','green onions'];let grocery = [. . . fruits,. . . veggies];console. log(grocery);// ['apples','bananas','strawberry','cabbage','asparagus','green onions']Spread operator can also be used to clone an array &amp; objects in an arrow function. 123456const dog1 = { name: 'Boop', breed: 'Corgi'}const dog2 = {. . . dog1}Rest Parameter: This is used to pass an arbitrary number of argument, and to process these args within the arrow function. Rest parameters are array instances. We use rest parameters if we need extra parameters other than the specified ones. 1234567let foo = function(a, b, . . . args) { console. log(args);}foo(1,2); // [], nothing will print inside the array, because we don't have extra parametersfoo(1,2,3,4,5) // [3,4,5]Difference between rest parameter and normal arguments Rest parameters returns an array by default, so methods like map, sort, shift, forEach… can be used directly. But for normal args, they need to be converted into an array because normal args are objects. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/react-01/",
    "title": "Intro to React",
    "body": "2020/12/17 - 短篇 React 學習筆記。 Intro to React: React = JS library for building user interfaces or UI components. Features:  JSX - JavaScript Syntax Extension Virtual DOM One way data binding Extensions DebuggingAdvantages &amp; Limitations: Virtual DOM: React uses virtual DOM which is a JS object. This will improve apps performance, since JS virtual DOM is faster than regular DOM. Usability:React can be used on client and server sides as well as with other frameworks (i. e. NativeScript). Maintenance:Component and data patterns improve readability, which helps to maintain larger apps. But React covers only the view part of the app. So to complete the entire development we would have to choose other technologies. "
    }, {
    "id": 22,
    "url": "http://localhost:4000/hello-native-script/",
    "title": "前端也可以寫手機 app ? 神奇的框架: NativeScript",
    "body": "2020/12/11 - 「魔鏡啊，魔鏡，什麼東西可以讓我寫一次就產生蘋果和安卓的 app？」 「…哈囉？魔鏡？」 呃，好，不玩了，我們直接進主題。 首先，我們先來聊聊前端跟手機 app 這個話題: 這個 section 廢話很多，歡迎你跳過 在人人一台手機，以及只會寫 static site 就直接被淘汰的年代（哈囉，2004!），我們前端每年也有越來越多好玩的新玩具，任君挑選。 是的，華生，在前端框架年年出、年年更新的盛況下，現在前端寫的已經不是靜態網站了，我們基本上都在寫 web app ，配合可愛的後端隊友，一個個網頁版的 start up 服務就這樣被孵化出來。 那網頁版的都出來了，為什麼不寫手機 app 呢？ 呃，因為我是前端我不會（喂 因為寫手機 app 真的是個學問，每個平台都有自己的寫法、規範，除此之外還得學習不同的語言才寫的出來，寫的出來還只是基礎，還要畫面好看、功能好用、效能夠快。 喔，對了，還要 UI/UX 好用哦，啾咪。 不過，話說回來，各種 app 不就是這樣嘛，哈哈。 BUT，沒錯，就是這個 BUT 他出現了，我是前端就不能寫手機 app 嘛？ 我也想寫啊，可是因為（以下省略幾十行理由）我無法。 沒關係，這時候我們的心聲被聽到了（耶~ 我們現在有種神奇的科技，主張只要寫一次 code 就可以產出雙平台 apps，那就是 hybrid apps！ 關於 hybrid apps ，我們之後會細說，我們先來聊聊今天的主角（也是 hybrid apps 之一的）: NativeScript! 原理: 所以 NativeScript 到底是什麼東東？ 以下為了方便起見，我會直接將 Native Script 縮寫成 NS。 簡單來說，它就是個可以寫原生 iOS 跟 Android app 的 JavaScript Framework。 它不僅是 Open Source，也有著偉大的理想，就是讓工程師可以寫一次，就哪裡（ iOS + Android ）都可以用的框架（當然這是夢想，跟實際還是有很大的差別，不過夠接近了啦~） 那我們需要會什麼語言才能寫它咧？ NS 的好處是它有多種寫法可以選擇，前端三大框架霸主都可以：  React Angular Vue那泥，你不會？不想寫？ 沒關係，它還可以用最單純寫法：  Vanilla JavaScript TypeScript然後，重頭戲來了！ NS 最大特點就是可以存取原生（Native） iOS 跟 Android 的 classes！ 可是為什麼他可以寫原生 app，他不是用 JavaScript嗎？而 Native 又是什麼鬼？ 這個跟 NS 的結構有關，我們往下看。 結構: 所以他到底是怎麼讓雙平台 apps 跑起來的 &amp; 他到底用了什麼? 我們先來看看這個圖: NS 是用了來自 Google 的 JavaScript V8 virtual machine、Runtime &amp; bridge module 組建而成。 那他們都在幹嘛咧？我們快速看一下圖，對照下面的工作列表：  Virtual machine 負責翻譯 + 執行 JS code Bridge Module 負責翻譯呼叫原生手機的 API call，並把結果回傳， NS Runtimes 讓你可以用 JavaScript 呼叫 Android 跟 iOS 框架的 API NS Core modules 會幫你創建個 API ，把你的 JS 程式碼翻譯成原生平台可用的程式碼 NativeScript CLI 就是你要寫 app 的平台 NativeScript 插件（{N} Plugins），是整個 NS 的核心簡單來說：因為可以使用 API call 就能操控手機功能，所以 NS 可以讓你直接用 JavaScript （不需要會 Objective-C 或 Java ）寫出手機 app。 它可以讓你直接用 JS 就可以寫手機才有的功能！（就好比拍照啦、查看聯絡人啦、打電話…etc） 那我們能怎麼寫呢？: 說到這，可能很多朋友不確定 NS 是不是適合自己。 沒關係，我們有個試水溫的好方法，那就是 NS 官方推出的線上 Web IDE - NativeScript Playground！ NS Playground 只要下載官方推出的兩個 app， preview 跟 playground 即可線上編寫手機 app ，live 測試（很酷吧！ 而試水溫過，覺得 NS 好像還可以，就可以直接下載 Local Machine CLI 寫起來！ Full Setup Guide 因為 setup 太繁雜，就不帶大家一步步過了，請自行移步樓上鏈接處理 setup。 講完了 setup，我們接著來看看 NS 是怎麼產生 UI Layout 的。 NativeScript 的 UI Layout: 我們先看這張圖： NS 其實有一套類似 XML 的 UI 寫法，拿大家最熟悉的按鈕來說，一個按鈕就是: 1&lt;Button (tap)= onTap()  class= btn-primary  /&gt;再配合 CSS、 ScSS 的結合，就可以把 UI 繪製出來！ 可是，我們總不可能整個 app 都要自己寫吧？ 對，這個時候我們就要開始來聊聊 NS 的缺點，跟如何找資源了（抱大神大腿 NativeScript 插件 （主要結構之一）: 之前稍稍提到的 NS 本身也是靠插件堆起來的，包括主要核心 NativeScript Core，那 NS 官方的工程師有沒有釋放出資源給我們用呢？ 要說有嗎，其實並沒有，很多東西都得自己手寫，但是還是有啦。 我們的 NS MarketPlace ( NS 市集 ) 可是 NativeScript 實在是太冷門了，所以很多東西都沒有 up to date，都得自己創建，但還是有差不多 1563 個插件。 不過 2014 年被創建後，只有 16 個是被官方認證的插件，而半年內有更新的插件也只有 71 個。 嗯哼，你沒看錯，我們來聊聊 NS 的缺點吧。 NativeScript &amp; Hybrid Apps 缺點: 在開始前，我們先說說 Native vs Hybrid Apps。 我們看這個圖： Native Apps = 原生語言程式寫的 app，就是所謂的用 Java 寫的 Android app 或 Objective-C/Swift 寫的 iOS app。 Hybrid Apps = 混合語言程式寫的 app，就是前端三寶 (HTML/CSS/JS) 寫的，寫好的這些 code 會被裝進原生容器 (Native Container) ，透過手機上的瀏覽器引擎來呈現和執行 但是，其實 hybrid apps 跟實際 native apps 開發還是有差別的！ 為什麼? 因為 NS、React Native 這些 hybrid apps 相較於 native apps，還是有做不到的 10-20%。拿 React Native 來說，就是那些在 Facebook 的工程師不願意寫出來的那些複雜功能。（請去追殺這群傢伙 接著，我們來說 hybrid app 的性能 Hybrid Apps 依靠手機的瀏覽器速度 (假設我們用 Ionic 這個框架)，也就表示它基本上不可能像 native apps 那麼快。 那這和 NS 有什麼關係？ 因為 NS 也是 hybrid apps，所以它啟動的 loading 時間，基本上就是等待 Windows 95 電腦啟動，功能也是，而且 app 越大越慢。 非常小的討論社群 剛剛在講 plugins 的時候有提到。 NS 剛出來時，已經被大多數想寫 mobile 的工程師淘汰（那時 React &amp; React Native 都崛起啊，加上 NS 又複雜，當時也不支援 React… 所以基本上想寫 hybrid apps 都跑去寫 React Native，NS 根本沒人寫。 Hybrid Apps 框架大亂鬥: 這是之前研究框架是搜集出來的結果，不用一個字一個字查。 我直接以因為專案需求使用 NS 的主要工程師角色，很負責的用一句話帶過：珍惜生命，遠離 NativeScript。 好啦，也不能這麼混，我還是總結一下這個表單： 社團小、開發者也少、開發難度也不低，很多東西要自己寫 那，一直提到的社團小、開發者也少、開發難度也不低，NativeScript 到底有什麼能贏的過其他兩位的呢？ 第一點 Access to Native API。 NS 最大的賣點就是他可以直接呼叫 API，讓我們用寫 JS 的方法寫手機 app ，做到打電話、拍照、查看聯絡人的功能，可是 React Native 也可以啊，React Native 有 Native Module 不是嗎？ 對，可是相較於 Ionic 的話，NS 還是佔上風的，因為 Ionic 不支援手機 Native 的功能。 好吧，那這樣我們用 React Native，不就好了嗎？ 我們來看看第二點，不限制於 React 記得最開始我們有講到嗎？ NS 有5種不同的寫法，不會 React 還是可以寫！ NS 可以寫 Angular、Vue、React、JavaScript &amp; TypeScript （而我這個目前還在啃食 React 資訊、又因公司專案需求的工程師就這樣入了 NS 的坑） 那重點來了… Native Script 的缺點那麼多，為什麼我還會從零學起，並用 NativeScript 寫手機 app 呢？ 嗯，很簡單。 因為客戶要求。  其實，我還想私心跟大家 demo 一下 NS 的功能，可是礙於公司產品不可以 showcase，我之後再奉上一小段其他 side project app 的迷你 demo 吧， 請敬請期待。 謝謝各位的閱讀。 References: https://dev. to/ronakpatel70/nativescript-v-s-react-native-what-to-choose-for-cross-platform-app-development-d20https://tylerablake. github. io/nativescript-intro/https://buzzorange. com/techorange/2013/11/28/native-app-or-hybrid/https://insights. daffodilsw. com/blog/nativescript-vs-react-native-overview-and-comparisonhttps://blog. jscrambler. com/react-native-vs-ionic-vs-nativescript-a-practical-guide/https://blog. jscrambler. com/introduction-to-nativescript/https://www. quora. com/What-are-the-bad-sides-if-I-build-an-app-for-iOS-and-Android-using-NativeScript-and-Angular-compared-to-native-appshttps://nativescript. org/faq/how-does-nativescript-work/https://www. quora. com/Has-anyone-built-a-project-with-NativeScript-or-React-Native-and-which-seems-to-have-the-upper-handhttps://www. quora. com/Should-I-explore-iOS-development-along-with-my-hybrid-knowledge-and-experience-with-Angular-Ionic-and-NativeScript-Will-it-be-worth-my-timehttps://www. itread01. com/content/1544417462. html "
    }, {
    "id": 23,
    "url": "http://localhost:4000/hello-react/",
    "title": "今年黑五不購物，讀書去~",
    "body": "2020/11/25 - 那個去年黑五在打LoL、吃牛排的 Angular 工程師，今年怎麼開始學 React. js 啦？ 今年黑五不購物，讀書去~: 如題，去年的黑五我在打LoL、吃牛排，今年的我，不一樣了！我讀書。 我是一個平凡的 Angular 工程師，直到在誠品看到了一本 React. js 的教學書。於是，我變成了一個，會一點點 React. js 的前端工程師。 這週的星期五就是黑色星期五了，黑色星期五想必是要大大的購物一番，不過，因為我買到了這本書，我便一頭栽進去 React. js 的世界。 今年的黑五，都在看書和寫扣。 在這一週，我學會了 + 花費時間: 這一週每天約花五個小時念這本書，因為我的中文程度只有小學四年級。所以我需要花費大量時間理解 Concept，轉成英文確保自己理解後，再繼續實作。 於是他變成了這樣： 接下來的週末兩天，星期五花了 7 小時，星期六花了 5 小時，於是，新版的履歷就生出來囉！ 之前我的履歷長這樣 現在的履歷，登登！ RWD 也沒有問題！ 使用技術：React. js, React Hooks 欸，對，他上線了，在這裡: resume "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});