
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": " 404:  It seems we've run into some issues. Let's go home? "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "About C. Wu",
    "body": "追求使用者體驗的前端工程師。 熟悉JavaScript ES2015+、TypeScript 與 Angular 9。 Who's C?: I am a front-end developer and a UI/UX designer currently based in Taipei, Taiwan. Commonly referred to by friends and colleagues as Lily, I am passionate about weaving pixel-perfect visuals and clean code together to turn them into practical solutions.  When I am not coding or designing, you can usually find me shooting portrait photography, diving into another new JavaScript framework just for fun or walking around with a cup of tea on a sunny day. resume "
    }, {
    "id": 2,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "   Featured:                                                                                                                                                                                                   基本功練習: Hacker News! — 目錄                              :               基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                                                                                                                                                                                                         Bidirectional data flow in React                              :               短篇 React 學習筆記: 使用 React Hooks 讓 React 能像 Angular 一樣做出 [(ngModel)] 的效果。:                                                                                                                                                                                                                                             React 跟 Angular 的框架分析 — Part 3: 兩個框架的優缺點                              :               歡迎再度回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                                                                                                                                                                             React 跟 Angular 的框架分析 — Part 2: 框架趨勢                              :               歡迎回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                                                                                                                                                                                 React 跟 Angular 的框架分析 — Part 1: Angular 跟 React 的快速背景                              :               歡迎來到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！:                                                                                                                                                                                                                                                                                         前端也可以寫手機 app ? 神奇的框架: NativeScript                              :               「魔鏡啊，魔鏡，什麼東西可以讓我寫一次就產生蘋果和安卓的 app？」:                                                                                                                                                                                                                                             今年黑五不購物，讀書去~                              :               那個去年黑五在打LoL、吃牛排的 Angular 工程師，今年怎麼開始學 React. js 啦？:                                                   All Stories:                                                                                       基本功練習: Hacker News! — 目錄              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 7: 「我的最愛」              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 6: 使用 Store              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 5: Redux              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 4: Recursion              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 3: 單獨頁面              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 2: API              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           基本功練習: Hacker News! — Part 1: 骨架              :       基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。:                                                                                           Bidirectional data flow in React              :       短篇 React 學習筆記: 使用 React Hooks 讓 React 能像 Angular 一樣做出 [(ngModel)] 的效果。:                &laquo; Prev    1    2    3    Next &raquo;  "
    }, {
    "id": 4,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %}  {% if post. featured == true %}  {% include featuredbox. html %}  {% endif %}  {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %}  {% include postbox. html %}  {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 6,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %}  {% if post. featured == true %}  {% include featuredbox. html %}  {% endif %}  {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %}  {% include postbox. html %}  {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 7,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p8/",
    "title": "基本功練習: Hacker News! — 目錄",
    "body": "2021/01/13 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 我是目錄:  骨架: html 結構 API: 串聯 API 單獨頁面: 顯示頁面 Recursion: 巢狀留言處理 Redux: state 管理佈局 使用 store: action + dispatch 「我的最愛」: 頁面撰寫同場加映: 用 React + React Hooks 把 Hacker News 寫出來~ "
    }, {
    "id": 8,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p7/",
    "title": "基本功練習: Hacker News! — Part 7: 「我的最愛」",
    "body": "2021/01/13 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 前情提要: 最後衝刺了，我們把 「我的最愛」寫出來吧！ 我的最愛: 頁面: 既然要這個頁面，那我們就必須弄一個新的，然後把他加進 routes 裡面： router. js: 1234567891011121314// 省略以上import Favorites from '. /pages/favorites. js';createRoutes() { const routes = [  { path: '/', page: Stories },  { path: '/new', page: Stories },  { path: '/ask', page: Stories },  { path: '/show', page: Stories },  { path: '/item', page: Item },  { path: '/favorites', page: Favorites } ];// 省略以下favorites. js: 12345import view from '. . /utils/view. js';export default function Favorites() { view. innerHTML = `&lt;div&gt;Favorites&lt;/div&gt;` }還是一樣，先讓它出來，我們再來改內容。 所以「我的最愛」要幹嘛，顯示 favorite state 啊，廢話。 把 store 丟進來吧！ 1234import store from '. . /store. js';const { favorites } = store. getState(); const hasFavorites = favorites. length &gt; 0; 我們直接取得 favorites 的 state，接著像其他頁面一樣寫判斷，如果有的資料話才顯示，沒有的話顯示訊息叫用戶加吧~ favorites. js: 12345678910111213141516import view from '. . /utils/view. js';import checkFavorite from '. . /utils/checkFavorite. js';import store from '. . /store. js';import Story from '. . /components/Story. js';export default function Favorites() { const { favorites } = store. getState();  const hasFavorites = favorites. length &gt; 0;    view. innerHTML = `&lt;div&gt;  ${hasFavorites ? favorites. map(story =&gt; Story({    . . . story,    isFavorite: checkFavorite(favorites, story)  })). join('') :  加一點東西進來吧! } &lt;/div&gt;` }耶，可以加進去了！ 但怎麼刪不掉咧？因為你還沒寫啊 XD 刪除的邏輯跟 Stories 很類似，複製貼上改一改就好了，像這樣… 12345678document. querySelectorAll('. favorite'). forEach(favoriteButton =&gt; { favoriteButton. addEventListener('click', function() {  const story = JSON. parse(this. dataset. story);   const isFavorited = checkFavorite(favorites, story);  store. dispatch({ type: isFavorited ?  REMOVE_FAVORITE  :  ADD_FAVORITE , payload: { favorite: story } })   Favorites(); }); });不過為什麼 addEventListener 的 callback function 不是 async 了？ 因為 Favorites 沒有用到 API，所以就不需要用到 async function 啊。 記得發完 action 後，讓 Favorite 重刷即可。 最後… favorites. js: 12345678910111213141516171819202122232425import view from '. . /utils/view. js';import checkFavorite from '. . /utils/checkFavorite. js';import store from '. . /store. js';import Story from '. . /components/Story. js';export default function Favorites() { const { favorites } = store. getState();  const hasFavorites = favorites. length &gt; 0;    view. innerHTML = `&lt;div&gt;  ${hasFavorites ? favorites. map(story =&gt; Story({    . . . story,    isFavorite: checkFavorite(favorites, story)  })). join('') :  Add some favorites! } &lt;/div&gt;`    document. querySelectorAll('. favorite'). forEach(favoriteButton =&gt; {   favoriteButton. addEventListener('click', function() {    const story = JSON. parse(this. dataset. story);     const isFavorited = checkFavorite(favorites, story);    store. dispatch({ type: isFavorited ?  REMOVE_FAVORITE  :  ADD_FAVORITE , payload: { favorite: story } })     Favorites();   });  });}我們的簡易版 Hacker News 就寫好了！ 耶~~ "
    }, {
    "id": 9,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p6/",
    "title": "基本功練習: Hacker News! — Part 6: 使用 Store",
    "body": "2021/01/13 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 前情提要: Store 處理好了，兩個主要功能：加入我的最愛 + 移除我的最愛也創建了，現在我們來運用它吧！ 我的最愛: Store: 我們的 store 創建好了，那現在我們要把它擺在哪邊咧？所有 data 在的地方：stories. js 在顯現 stories 的地方，我們需要再加一個 data，用來判斷這條新聞，有沒有被加進「我的最愛」裡面。 1${hasStories ? stories. map((story, i) =&gt; Story({ . . . story, index: i + 1 })). join('') : '沒新聞耶'}該怎麼處理咧？ 首先，我們要先把 store 導進來，並拿到我們的「我的最愛」清單。 123import store from '. . /store. js';const { favorites } = store. getState();他們兩個都進來後，現在我們要判斷每條新聞，是否已經被加進去 favorites 的 state 裡面了。 這時候我們需要寫一個 function 檢查它，再回傳個 true or false boolean。 checkFavorite. js: 12345import checkFavorite from '. . /utils/checkFavorite. js'; export default function checkFavorite(favorites, story) { return favorites. some(favorite =&gt; favorite. id === story. id);}這個檢查 function 寫好後，我們就可以把它塞進我們的 data 裡了！ 1${hasStories ? stories. map((story, i) =&gt; Story({ . . . story, index: i + 1, isFavorite: checkFavorite(favorites, story) })). join('') : '沒新聞耶'}這邊 Story function 會接受 object parameter，裡面有個 property 叫做 isFavorite。 isFavorite 裡面會直接用 checkFavorite function 檢查，這條新聞是否有在 favorites state 裡面。 寫好後，我們就可以去 Story. js 按照判斷把 toggle 寫出來。 story. js: 12345678910export default function Story(story) { return `  // 中間省略   &lt;span class= favorite &gt;    &amp;hearts;    ${story. isFavorite ?  從我的最愛移除  :  新增至我的最愛 }   &lt;/span&gt;  // 這邊也省略 `;}撰寫點擊 event: 現在就是當我們按下，「新增至我的最愛」或「從我的最愛移除」這筆資料會進我們的 state，或從我們的 state 裡面消失。 我們需要一個 click event！就放在 這邊吧！ 我們再次回到 stories. js: 12345document. querySelectorAll('. favorite'). forEach(favoriteButton =&gt; { favoriteButton. addEventListener('click', function() {  //. . . 我們要在這裡寫判斷 }); });但是等等，如果這個 span 上面已經有我要的 story data，那我判斷起來會更方便，我們來修改一下 1234&lt;span class= favorite  data-story='${JSON. stringify(story)}'&gt; $hearts; ${story. isFavorite ?  從我的最愛移除  :  新增至我的最愛 }&lt;/span&gt;這樣的話，我們直接用 this. dataset. story 就可以抓到 story 了！ 首先為了檢查這筆資料是不是在 state 裡面，我們需要把它變回 object，然後檢查他，所以… 12const story = JSON. parse(this. dataset. story); // 讓它變回 objectconst isFavorited = checkFavorite(favorites, story); // 會回傳 boolean接下來，我們就可以用 dispatch 更新 store 了 1store. dispatch({ type: isFavorited ?  REMOVE_FAVORITE  :  ADD_FAVORITE , payload: { favorite: story } })如果他已經被加進「我的最愛」了，那就發 REMOVE_FAVORITE 的 Action，沒有的話那發 ADD_FAVORITE 的 Action。 payload 按照我們的 state object 來寫： { favorite: story }。 接著我們更新 store： 1await Stories(path);然後，就出錯了 XD 因為我們的 callback function 不是 async，但是沒關係，加上去就 ok 了： stories. js: 1234567891011121314151617181920212223242526// 省略 importexport default async function Stories(path) { const { favorites } = store. getState();  const stories = await getStories(path); const hasStories = stories. length &gt; 0;           view. innerHTML = `&lt;div&gt;  ${hasStories ? stories. map((story, i) =&gt; Story({ . . . story, index: i + 1, isFavorite: checkFavorite(favorites, story) })). join('') : '沒新聞耶'} &lt;/div&gt;`;   document. querySelectorAll('. favorite'). forEach(favoriteButton =&gt; {   favoriteButton. addEventListener('click', async function() {    const story = JSON. parse(this. dataset. story);     const isFavorited = checkFavorite(favorites, story);    if (isFavorited) {     store. dispatch({ type:  REMOVE_FAVORITE , payload: { favorite: story } })     } else {     store. dispatch({ type:  ADD_FAVORITE , payload: { favorite: story } })      }    await Stories(path);   });  });}// 省略 getStories我們終於把加入我的最愛 + 移除我的最愛，除了讓 code 更精簡以外，還有最後一件事，我們的 Hacker News 就大功告成了，那就是… 創建「我的最愛頁面」！(講了超多次，到底要不要寫啦！ "
    }, {
    "id": 10,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p5/",
    "title": "基本功練習: Hacker News! — Part 5: Redux",
    "body": "2021/01/12 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 前情提要: 我們個別頁面跟留言都處理好了，現在我們要來動手寫我的最愛了！ Redux: 上一篇提到，我們只剩下最後一個功能，我的最愛頁面。 而這一塊，我想用 Redux。 這樣就可以讓用戶在新聞列表直接將喜歡的新聞加進我的最愛頁面，也可以在將新聞從我的最愛移除。 最重要的是，在我們切換頁面時，資料不會流失！ 我們來快速回顧下 Redux 是什麼： Redux 是個全域的狀態管理物件，用來管理 state，主要目的是方便我們把 state 資料傳來傳去。 我們用 Action 下指令，接著 Reducer 會依照發射的指令處理我們在 state 的資料，再把更新好的資料傳到 store 裡，最後 store 會依照拿到的資料將畫面更新，這樣子輪迴。 喔對了，神奇的小常識。 Redux 跟 Flux 其實基本上指的是同樣的 concept，不過 Flux 可以同時擁有很多 store，Redux 只能有一個。 回顧完了 Redux，我們接著寫 Hacker News。 我的最愛: Store: 在開寫前，我們先想想這頁要幹嘛。 我想要搜集所有用戶按下喜歡的新聞，並把它們存放到這頁，而其他的新聞列表上，如果用戶已經按下喜歡了，那列表上則會顯示「從我的最愛中移除」。 要做這個功能的話，我們需要一個地方搜集所有的喜歡資料，而這個地方，我就叫它 store. js。 但是在開始創建 store 前，我需要先有 reducer 來幫我保管 state，所以我們先寫 reducer。 Reducer = 如上，在 Redux 裡面，用來保管 state 的東東，可以接受指令去更新 state。 store. js: 12345678910const initialState = { favorites: [] }function favoritesReducer(state = initialState, action) { switch (action. type) {  default:   return state; } }我們空的 initialState，還有空空的 favoriteReducer。 在 favoriteReducer 裡面，我們需要兩個功能：加入我的最愛 + 移除我的最愛。 加入我的最愛： 12345case  ADD_FAVORITE : { const addedFavorite = action. payload. favorite; const favorites = [. . . state. favorites, addedFavorite]; return { favorites };}創建一個 array，用 spread operator 在現有的 state 裡面將 addedFavorite 裝進去。 移除我的最愛： 12345case  REMOVE_FAVORITE : { const removedFavorite = action. payload. favorite; const favorites = state. favorites. filter(favorite =&gt; favorite. id !== removedFavorite. id); return { favorites };}找到要移除我的最愛，在現有的 state 裡面，用 . filter 排除掉這個 id。 至於什麼 action 都沒設定時，如果 favoritesReducer 被呼叫，那就會直接回傳 state 了。 12default: return state;把他們加起來，就是這樣： store. js: 1234567891011121314151617181920const initialState = { favorites: [] }function favoritesReducer(state = initialState, action) { switch (action. type) {  case  ADD_FAVORITE : {   const addedFavorite = action. payload. favorite;   const favorites = [. . . state. favorites, addedFavorite];   return { favorites };  }  case  REMOVE_FAVORITE : {   const removedFavorite = action. payload. favorite;   const favorites = state. favorites. filter(favorite =&gt; favorite. id !== removedFavorite. id);   return { favorites };  }  default:   return state; } }現在 Reducer 有了，我們把 store 建立出來吧： 123function createStore(reducer) { let currentState = reducer(undefined, {});}createStore 會接受一個 reducer，而 currentState 最開始創建事是空的，也沒有任何需要被下的指令，所以我們寫這個: reducer(undefined, {}) 這樣 default state 就會被回傳回來了。 可是，我們要怎麼拿到這個 currentState 咧？ 我們幫 createStore 創建兩個 function: getState 跟 dispatch: 12345678910function createStore(reducer) { let currentState = reducer(undefined, {});  return {  getState: () =&gt; currentState,  dispatch: action =&gt; {   currentState = reducer(currentState, action);    }  }}getState 可以讓我們拿到現有的 state，而 dispatch 會依照收到的 action 幫我們自動更新 currentState。 剩下就是把 store 建起來，讓整個 app 能用了。 123const store = createStore(favoritesReducer);export default store;這個寫好後，我們就可以將 store 導入進需要的畫面，歡樂的使用 store. getState() 跟 store. dispatch(action) 了! 佈局這麼久，終於可以開始寫我的最愛了，耶~~ "
    }, {
    "id": 11,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p4/",
    "title": "基本功練習: Hacker News! — Part 4: Recursion",
    "body": "2021/01/12 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 前情提要: 我們個別頁面已經寫好啦，現在該來處理醜醜的留言顯示了！ 留言顯示: 開始前，我們先來觀察一下 comments。 注意到了嗎？他是一層又一層的！(nested object) 我們在寫 comments 這頁時，要把這個特點考慮進去。 先繼續依照 React 的 Component 邏輯，把每個 comments 拆到他們各自的 Component 裡面吧： item. js: 12345678910111213141516// 以上省略export default async function Item() { const story = await getStory();  const hasComments = story. comments. length &gt; 0;  view. innerHTML = ` &lt;div&gt;  ${Story(story)} &lt;/div&gt; &lt;hr/&gt; ${hasComments ? story. comments. map(comment =&gt; Comment(comment)). join('') : '沒留言耶'} ` }// 以下省略Comment. js: 1234567891011export default function Comment(comment) {  console. log(comment);   return `  &lt;div class= nested-comments-0 &gt;   &lt;p class= comment-header &gt;    ${comment. user} | ${comment. time_ago}   &lt;/p&gt;   ${comment. content}  &lt;/div&gt; `  }我們來看看畫面： 留言出來了沒錯，可是有看到每一筆下面還有一層 comments 嗎？ 這就是我們之前觀察到的 nested comments，我們需要處理他！ 我們需要讓 Comment 一直產生畫面直到 comments 裡面沒有任何 comments 為止。 所以，先寫個判斷是否有 nested comments 吧。 1const hasNestedComments = comment. comments. length &gt; 0;如果有 nested comments 的話，那我們加個判斷讓他產生畫面： 1234567891011121314export default function Comment(comment) { const hasNestedComments = comment. comments. length &gt; 0; return `  &lt;div class= nested-comments-0 &gt;   &lt;p class= comment-header &gt;    ${comment. user} | ${comment. time_ago}   &lt;/p&gt;   ${comment. content}   ${hasNestedComments ? comment. comments. map(comment =&gt; Comment(comment)). join(  ) :   }  &lt;/div&gt; `  }1${hasNestedComments ? comment. comments. map(comment =&gt; Comment(comment)). join(  ) :   }這一行的意思是，如果 hasNestedComments = true 的話，那 Comment function 會一直自己呼叫自己直到 hasNestedComments = false。 也就是所謂的 recursion function！ 再修改一下 css，讓每一層巢狀 comments 都會被往右邊推。 1&lt;div class= nested-comments-${comment. level} &gt;我們的留言區就變成這樣了~ 快寫完了！現在我們只剩下最後一個功能，我的最愛頁面。 而這一塊，我想用 Redux pattern。 這樣就可以讓用戶在新聞列表直接將喜歡的新聞加進我的最愛頁面，也可以在將新聞從我的最愛移除。 最重要的是，在我們切換頁面時，資料不會流失！ "
    }, {
    "id": 12,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p3/",
    "title": "基本功練習: Hacker News! — Part 3: 單獨頁面",
    "body": "2021/01/11 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 前情提要: 我們的列表頁面已經寫好了，現在是個別頁面以及留言顯示了！ 個別頁面: 注意到之前的頁面了嗎？每當我們點進去一則新聞時，route 會變成這個： #/item?id=25757398 依照 React 的 Component 邏輯，我們要再創建一個叫做 Item 的 Component 來當個別頁面。 我們先來到 router 這邊把 item 丟進去： router. js: 123456789101112131415import Stories from '. /pages/stories. js';import Item from '. /pages/item. js'; // item 頁面// 這邊省略  createRoutes() {  const routes = [   { path: '/', page: Stories },   { path: '/new', page: Stories },   { path: '/ask', page: Stories },   { path: '/show', page: Stories },   { path: '/item', page: Item }  ];  // 下面省略還是那句話，先確保東西有吐在畫面上再慢慢 format。 item. js: 12345import view from '. . /utils/view. js';export default function Item() { view. innerHTML = `&lt;div&gt;item&lt;/div&gt;` }好，東西有了，那我們開始把畫面刻出來。 再開始之前，我們知道每條新聞都有自己專屬的 id，我們需要抓到這個 id，才可以呼叫 API 顯示它對應的留言。 那要怎麼拿呢，我們可以用 . split 的方式來寫： 1const storyId = window. location. hash. split('?id=')[1];split 會創建一個 array，把 ?id= 前後的資訊分別塞進 array 裡。 我們只要這樣即可拿到 id。 我們接著寫呼叫 API 的 code。 123456async function getStory() { const storyId = window. location. hash. split('?id=')[1]; const response = await fetch(`https://node-hnapi. herokuapp. com/item/${storyId}`); const story = await response. json(); return story;}因為是 async 所以我們要等資料回傳，app 才不會壞掉。 可是既然我們要這麼抓 story ，那我們顯示 Item 的那塊就也要變成 async function （要等 story 進來）。 所以… item. js: 123456789101112131415161718import Story from '. . /components/Story. js';import view from '. . /utils/view. js';export default async function Item() { const story = await getStory();   view. innerHTML = ` &lt;div&gt;  ${Story(story)} &lt;/div&gt;` }async function getStory() { const storyId = window. location. hash. split('?id=')[1]; const response = await fetch(`https://node-hnapi. herokuapp. com/item/${storyId}`); const story = await response. json(); return story;}登登~ 這邊我們重複利用了之前寫的 Story Component，把資料顯示出來。 不過，因為這個頁面不是列表，所以我們要修改 story. js 把 index 拿掉。 story. js: 1&lt;span class= gray &gt;${story. index ||   }&lt;/span&gt;這樣 Item 就不會出現 undefined 了（因為沒有排列數字）。 我們接著我們要讓 comments 出來，就像我們之前寫 Story 一樣，以此類推： item. js: 12345678910111213141516// 以上省略export default async function Item() { const story = await getStory();  const hasComments = story. comments. length &gt; 0;  view. innerHTML = ` &lt;div&gt;  ${Story(story)} &lt;/div&gt; &lt;hr/&gt; ${hasComments ? story. comments. map(comment =&gt; JSON. stringify(comment)). join('') : '沒留言耶'} ` }// 以下省略然後，我們又可以看到那個醜到不行的頁面了 XD 可是，如果 Item 的 id 不對呢？ 沒有這個頁面，怎麼辦？ 我們可以在呼叫 API 時，寫一個判斷確保它沒出錯，如果出錯了（id 錯誤，抓不到之類的）， 我們會直接跟用戶講。 這邊用到配合 async + await function 的 try catch 功能。 123456789101112let story = null;let hasComments = false; let hasError = false; try {   story = await getStory();   hasComments = story. comments. length &gt; 0;} catch(error) {  hasError = true;   console. error(error);} 另外，既然我們要跟用戶說畫面有錯誤，我就需要一個 local state boolean 去判斷，然後顯示畫面。 12345let hasError = false;if (hasError) {  view. innerHTML = `&lt;div class= error &gt;抓不到資料耶。&lt;/div&gt;`;}再把它裝進 try catch 裡面。 組裝起來就是這樣: item. js: 12345678910111213141516171819202122232425export default async function Item() { let story = null; let hasComments = false;  let hasError = false;   try {   story = await getStory();    hasComments = story. comments. length &gt; 0; } catch(error) {   hasError = true;   console. error(error); }   if (hasError) {   view. innerHTML = `&lt;div class= error &gt;抓不到資料耶。&lt;/div&gt;`; }  view. innerHTML = ` &lt;div&gt;  ${Story(story)} &lt;/div&gt; &lt;hr/&gt; ${hasComments ? story. comments. map(comment =&gt; JSON. stringify(comment)). join('') : 'No comments'} ` }我們接著來亂輸入 Item id，就會出現這個畫面了： 接下來就是把 Comments 全部都吐出來了！ "
    }, {
    "id": 13,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p2/",
    "title": "基本功練習: Hacker News! — Part 2: API",
    "body": "2021/01/11 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 前情提要: 我們的 Hacker News 框架已經出來呢，現在就是把資料丟進去。 這裡我們會用 API 去抓資料，配合對應的 routes 把他顯示出來。 API: 先把東西弄出來再慢慢 format。 要用的 API 是這個：https://node-hnapi. herokuapp. com 接著要用 async + await 寫我們的 stories。 stories. js: 123456789101112131415161718192021222324import view from '. . /utils/view. js';export default async function Stories(path) { const stories = await getStories(path); const hasStories = stories. length &gt; 0;           view. innerHTML = `&lt;div&gt;  ${hasStories ? stories. map(story =&gt; JSON. stringify(story)) : '沒有 stories 耶'} &lt;/div&gt;`; }async function getStories(path) { const isHomeRoute = path === '/'; const isNewRoute = path === '/new'; if (isHomeRoute) {  path = '/news';  } else if (isNewRoute) {  path = '/newest';  }  const response = await fetch(`https://node-hnapi. herokuapp. com${path}`); const stories = await response. json(); return stories;}我們的畫面就會變成這個鬼樣子： 嗯，很醜。 不過，沒關係，我們來美化它。 資料一大坨進來，依照我們的 React 原理，現在是應該把他拆成可以重複使用的原件了，我們的 Component！ 以此類推，我們要建立一個新的 js 檔來裝每條新聞。 首先我們先把 API data 丟進創建好的 Story Component。 12345678910111213import Story from '. . /components/Story. js'; // import 進來import view from '. . /utils/view. js';export default async function Stories(path) { const stories = await getStories(path); const hasStories = stories. length &gt; 0;           view. innerHTML = `&lt;div&gt;  ${hasStories ? stories. map((story, i) =&gt; Story({ . . . story, index: i + 1 })). join('') : '沒新聞耶'} &lt;/div&gt;`; }// 以下省略我稍微解釋一下為什麼這邊會這樣寫： 1stories. map((story, i) =&gt; Story({ . . . story, index: i + 1 })). join('')首先，stories 會吐出有一堆 object 的 array，所以需要用到 . join(‘’) 才不會每一筆資料都有 , 在後面。 然後，我們想要在每條新聞前顯現順序數字，可是 array 是從 0 開始，所以我們在 map 裡面要用 i + 1 來設立 index。 因為 Story Component 只接受一個 parameter，所以我們用 object 的方式，配合 spread operator 去寫他。 最後，只要把 Story Component，照著 Hacker News 的模式 把畫面刻出來，就 OK 了~ story. js: 1234567891011121314151617181920212223242526export default function Story(story) { return `  &lt;div class= story &gt;   &lt;div&gt;     &lt;span class= gray &gt;${story. index}&lt;/span&gt;    &lt;span class= upvote &gt;▲&lt;/span&gt;    &lt;a href= ${story. url} &gt;${story. title}&lt;/a&gt;    &lt;span&gt;(${story. domain})&lt;/span&gt;   &lt;/div&gt;   &lt;div&gt;    &lt;div class= gray &gt;     ${story. points} points by ${story. user} ${story. time_ago}     |     &lt;a href= #/item?id=${story. id} &gt;      ${story. comments_count} comments     &lt;/a&gt;     |     &lt;span class= favorite &gt;      &amp;hearts;      Add To Favorites     &lt;/span&gt;    &lt;/div&gt;   &lt;/div&gt;  &lt;/div&gt; `; }我們再來看看畫面： 嗯，好多了。 下一篇，我們接著要寫每條新聞按進去後，可以看到留言的頁面~ "
    }, {
    "id": 14,
    "url": "http://localhost:4000/vanilla-js-hacker-news-p1/",
    "title": "基本功練習: Hacker News! — Part 1: 骨架",
    "body": "2021/01/10 - 基本功練習: 使用純 JS + Redux 把 Hacker News 做出來。 Hacker News！: 這是簡單版的 Hacker News 成品~ 最近在練習 JS 基本功，不用框架直接用了 vanilla JS + Redux 把它寫出來。 之後會同場加映 React 版本（包含 Hooks）。 我們開始吧~ 骨架: 其實 Hacker News 網頁的本身框架很簡單，就是 header 加一個 nav 再來一個 body container，這邊就不多講 HTML，直接跳 JS 的部分。 因為練習基本功所以不用框架，但我還是想按照類似結構：使用單個 html 檔案，並將其他網頁語法用 JS 填進去。 如果我想要這個 app 的框架原理跟 React 類似，那我們回想下 React 的基礎結構： React 的 setup 原理採用只有單個 html 檔案，並將其他網頁語法用 JS 填進去。 1234567&lt;div id= root &gt;&lt;/div&gt;ReactDOM. render(&lt;App /&gt;, document. getElementbyId('root'));class App extends React. Component { //. . . }Ok，那我們以此類推，用 JS module 把整個畫面寫出來，然後想辦法讓 JS 只 update 一個地方即可。 關於 routing 的部分，我們用 hash router 來連結不同頁面，為了節省時間用第三方插件 Navigo。（用純 JS 把 Router 寫出來太費時了，我還要寫 React 啊！） 我們先寫一些測試 code 確保這個寫法是 OK 的。 首先是單個 html 框架： 12345678910&lt;!-- 上面省略 --&gt;&lt;div id= route-container &gt; &lt;div id= router-outlet &gt;&lt;/div&gt;&lt;/div&gt;     &lt;script type= module  src= app. js &gt;&lt;/script&gt;&lt;script src= //unpkg. com/navigo@6 &gt;&lt;/script&gt;&lt;!-- 下面省略 --&gt;先把我們的 Router 架好，並在 app. js 設定它： App. js: 123456789import RouterHandler from '. /router. js'class App { constructor() {  new RouterHandler(); } }new App();Router 本身： router. js: 1const router = new Navigo(null, true, '#');有了 router，就可以切換頁面了。 跟著 React 的結構繼續走，畫面要更新那 JS 會直接在某個 div 裡面添加資訊，這裡是： 1&lt;div id= router-outlet &gt;&lt;/div&gt; 所以我們需要一個 querySelector，就叫他 view. js。 view. js: 1export default document. querySelector('#router-outlet');然後把我們要的資訊裝進去。 stories. js: 12345import view from '. . /utils/view. js';export default function Stories(path) { view. innerHTML = `&lt;div&gt;${path}&lt;/div&gt;`; }我把每個 route 的放進一個叫 Stories 的 container 頁面（因為 Stories 裡面之後會裝一條條單個 Story）。 為什麼會是 path 當 parameter 咧？ 之前提到過，我們用 hash router 來連結不同頁面，而用戶點擊不同頁面的時候，我的 router 會顯示不同畫面。 每個畫面產生的東西（之後會從 API 抓資訊），當然是透過 path 進去。 我們看下 Navigo 的 doc，把 router 切換寫好。 router. js: 123456789101112131415161718192021222324import Stories from '. /pages/stories. js';const router = new Navigo(null, true, '#');export default class RouterHandler { constructor() {  this. createRoutes()  }   createRoutes() {  const routes = [   { path: '/', page: Stories },   { path: '/new', page: Stories },   { path: '/ask', page: Stories },   { path: '/show', page: Stories }   ];    routes. forEach(({ path, page }) =&gt; {   router. on(path, () =&gt; {     page(path);    }). resolve();  }) }}頁面 setup 就完成了，我們下一集會接著把每條新聞用 API 抓進來。 "
    }, {
    "id": 15,
    "url": "http://localhost:4000/react-12/",
    "title": "Bidirectional data flow in React",
    "body": "2021/01/05 - 短篇 React 學習筆記: 使用 React Hooks 讓 React 能像 Angular 一樣做出 [(ngModel)] 的效果。 coming soon！ "
    }, {
    "id": 16,
    "url": "http://localhost:4000/react-vs-angular-part-3/",
    "title": "React 跟 Angular 的框架分析 — Part 3: 兩個框架的優缺點",
    "body": "2020/12/31 - 歡迎再度回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！ 這篇分析會切成以下四個部分，你現在在這裡： Angular 跟 React 的快速背景快速帶過近幾年兩個框架的發展 trends （更詳細的 trends 分析會另外開一篇）兩個框架的優缺點，每提一點，會附上實作 comparison下集預告：配合後端 + 串起 API 後，誰勝出準備好的話，我們就開始囉~ 框架優缺點: 如果可以拿食物來形容兩個框架的話，React 是單點套餐，可以一直加不同的配餐，而 Angular 就是全家桶一次給你、給你、都給你。 一切取決於你想要什麼東西。 但是，嘰裡呱啦講了那麼多，我們怎麼知道誰比較好？ 簡單，寫出來就知道了！ 接來下，我們拿 Todo List 當例子，把這個範例用 Angular 跟 React 各寫一次。 並在寫 code 時分析並提出兩個框架的優劣處。 框架結構: 首先我們來理解一下 Angular 的結構Angular 是採 MVC 方式，也就是說一個 component 上面，你會有 4 個檔案：  TypeScript：component 邏輯 css/scss: 如名 style 檔案 HTML: 呈現的網頁 spec. ts: 測試檔在 TypeScript 檔案裡面寫好你的 class，html 顯示你的 template，scss 呈現 style，最後用 spec 來測試。 而 React 在資料結構上，就乾淨簡潔的許多 如果採用 JSX 的話， React 就只有一個 JSX 檔。 而我們之前提過 React 採取了 Virtual DOM 的方式，用 JSX 寫法的話，我們可以選擇要寫 class component 或是 functional component。 近幾年，因為 React Hooks 的崛起，functional 開始被重用，而 loading 的速度也更快了。 要測試 React 的話，跟 Angular 一樣 React 需要額外寫測試檔，但不一定每個 component 都要單獨寫一個！ React 個人小偏好 在 React 的資料夾結構上，我個人偏好是這樣： components:  Book     index. js   Book. jsx   把寫好的 component 分裝進一個專屬的資料夾，裡面有 index. js 跟 component 的 jsx 檔案。 在將 index. js 輸出 component，方便其他頁面讀取。 看完了結構，我們來聊聊撰寫時的便利度！ 接下來的部分重寫中，上次舉的例子沒有特別好，所以還請各位客官見諒，他很快就會被補回來的！ "
    }, {
    "id": 17,
    "url": "http://localhost:4000/react-vs-angular-part-2/",
    "title": "React 跟 Angular 的框架分析 — Part 2: 框架趨勢",
    "body": "2020/12/29 - 歡迎回到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！ 這篇分析會切成以下四個部分，你現在在這裡： Angular 跟 React 的快速背景快速帶過近幾年兩個框架的發展 trends （更詳細的 trends 分析會另外開一篇）兩個框架的優缺點，每提一點，會附上實作 comparison下集預告：配合後端 + 串起 API 後，誰勝出準備好的話，我們就開始囉~ 框架趨勢: 崛起的 React: 雖然 React 在 2013 正式發佈，但是根據各大網站分析 React 還是壟斷了市場。 我們來看一些 React vs Angular 的數據圖： 每年的下載數據： 過去兩年的下載數據 (2018-2020, NPMTrends. com)： 過去 5 年，在 Google Trends 上大家都在搜尋的框架 (2015-2020)： 這三張數據圖，都可以看到 React 已經稱霸前端框架了。 可是 Angular 不是比 React 早出來嗎？這是怎麼一回事？ 這裡我們要講到 Angular 的一段小歷史。 哭泣的 Angular: 上一篇有提到，其實大家很容易搞混 AngularJS 跟 Angular 2+。 我們來回顧下： AngularJS = 2010 年就推出的舊框架，明年即將被 Google 冷藏，不再支援。 Angular 2+ （又或是我們在市場常看的 Angular 7, Angular 8… Angular 11 等） = 2016 年才推出的框架，是 AngularJS 的升級版。 功能比 AngularJS 強大，但是還是很多人容易誤會，以為 Angular 2 = AngularJS。 也可以說 Angular 2+ 無辜被前輩 AngularJS 陷害，讓大家以為他還是很難用。 另外，我們現在 2020 年，公司一般如果提到 Angular，其實都是在說 Angular 2+，基本上已經沒有人在用 AngularJS 了。 但還是有很多人不明白，以為市場上說的 Angular 是 AngularJS。 而在這篇文章裡，我如果提到 Angular，就是在說 Angular 2+。 更新速度: 講完了兩個框架的趨勢已經釐清了小誤會，我們來聊一下框架版本的更新速度。 拿 Angular 來講，Angular 的官網表示每半年就會出一個 major release，每個 major release 都會被 Angular 支援 18 個月（半年 active support，一年 LTS）。 換句話說就是 Angular 工程師們有差不多半年的時間可以快速學習該版本的更新，學完後就要繼續迎接更新版本的 updates。 而 React 每個版本差不多是一年大更新一次，近幾年來最重大的是 React 16. 8，帶來了 React 未來的趨勢– Hooks! (這個我們接下來再細聊) 那我們再來看看 StackOverflow 上面的數據： 2020 年 StackOverflow 上，工程師最愛框架統計問卷: 我們一比之下，React 佔了快 7 成的前端市場，緊追在後的是近幾年崛起的 Vue. js（這個有機會我們再聊）。 而我們的 Angular ，雖然近幾年在前端沒有比 React 那麼吃香，但也佔據了 5 成。 而大家常常搞混的 AngularJS （ Angular的前身 ）只佔了 24 %，而且還榮登大家最討厭的框架之一： 2020 年 StackOverflow 上，工程師最恨框架統計問卷: 其實 Angular 跟 React 只差了 10% 而已，所以我們也可以說 Angular 其實是被 AngularJS 害慘了（因為大家常常分不清楚他們兩個）。 那都說 React 比 Angular 好，那他到底好在哪裡？ 我們看下去！ 下集預告：框架優缺點…: 市場趨勢講完了，我們終於要進入重頭戲框架優缺點，以及非常刺激的大對比。 沒錯，接下來我會以以往寫過不同案子的功能舉例，同時撰寫 Angular + React 並分析他們的優缺點！ 我們下次見，掰掰~ "
    }, {
    "id": 18,
    "url": "http://localhost:4000/angular-highlight/",
    "title": "學習筆記：Angular 特色",
    "body": "2020/12/29 - 學習筆記之Angular特色記載篇！！ Angular 特色: Angular 是 2016 年被推出的框架，一樣是 Google 開發的，可是兩者基本上是 Java 跟 JavaScript 的差別，基本上兩個不同的語言。 Angular 採用 JS ES6 來開發，它主要由 8 個部分組成： 模塊 (Modules)組件 (Components)模板 (Templates)元數據 (Metadata)數據綁定 (Data Binding)指令 (Directives)服務 (Services)依賴注入 (Dependency Injection)1. 模塊 (Modules) 模塊，如名由一塊塊代碼組成，用來執行簡單任務。 Angular 是模塊化的，有自己的模塊系統：NgModules。 而每個 Angular 專案至少要有一個模塊(根模塊，所謂的 Root Module)，一般為：AppModule。 Angular 模塊是一個帶有 @NgModule 裝飾器的類，它接收一個用來描述模塊屬性的元數據對象。 範例： 12345678910111213141516import { NgModule } from'@angular/core';import { BrowserModule } from'@angular/platform-browser';@NgModule( {imports: [BrowserModule], providers: [Logger], declarations: [AppComponent], exports: [AppComponent], bootstrap: [AppComponent] }) export class AppModule {}NgModule 裡面的屬性我就不一一講解了。 創建完 AppModule 後，通過導入根模塊來啟動我們的專案，開發過程通常在 main. ts 裡面來 import AppModule。 範例： 123456import { platformBrowserDynamic } from'@angular/platform-browser-dynamic';import { AppModule } from'. /app. module';platformBrowserDynamic(). bootstrapModule(AppModule);2. 組件(Components) Angular 核心，用來處理應用和邏輯頁面的 view，可用於整個專案。 要創建 Component ，我們得從 @angular/core 中引入 Component 修飾器 12345678@Component({ selector:  'app-hero-list', templateUrl: '. /hero-list. component. html', providers: [ HeroService ]})export class HeroListComponent implements OnInit {/* . . . */}3. 模板 (Templates) 模板 = HTML view 透過 component 裡面的 templateUrl 即可告知 Angular 如何顯示組件。 1&lt;div&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/div&gt;4. 元數據 (Metadata) Metadata 其實就是 Angular 用來將 class 定義成 component 的資訊。 範例： 1234567@Component({ selector:  'app-hero-list', templateUrl: '. /hero-list. component. html', providers: [ HeroService ]})export class HeroListComponent implements OnInit {/* . . . */5. 數據綁定 (Data Binding) 管理應用程式裡面數值的一種機制，可以從HTML裡面取值和賦值，使得數據的讀寫，數據的持久化操作變得更加簡單快捷。 Angular 則有四種 data binding 模式。 每種形式都有自己的一個方向：從 DOM 來、到 DOM 去、雙向 我們看張圖： 插值: 在 HTML 中顯示組件值。 123&lt;h3&gt;&lt;/h3&gt;&lt;img src=  &gt;屬性綁定: 把元素的屬性設置為組件中屬性的值。 1&lt;img [src]= userImageUrl &gt;事件綁定: 在組件方法名被點擊時觸發。 1&lt;button (click)= onSave() &gt;save&lt;/button&gt;雙向綁: 使用 Angular 里的 NgModel 指令進行雙向綁定。 12&lt;input [value]= currentUser. firstName (input)= currentUser. firstName=$event. target. value  &gt;6. 指令 (Directives) 當 Angular 渲染模板時，它會根據指令對 DOM 進行修改。 Angular 有三種類型的 directives:  屬性指令：以元素的屬性形式來使用的指令。 結構指令：用來改變DOM樹的結構 組件：作為指令的一個重要子類，組件本質上可以看作是一個帶有模板的指令。範例： 123&lt;li *ngFor= let book of books &gt;&lt;/li&gt;&lt;book-info *ngIf= selectedBook &gt;&lt;/book-info&gt;*ngFor 告訴 Angular 為 books 列表中的每個項生成一個 &lt;li&gt; 標籤。 *ngIf 表示只有在 selectedBook 等於 true 時，才會包含 book-info 組件。 7. 服務 (Services) 服務是封裝了某一特定功能，並且可以通過注入的方式讓人使用的獨立模塊。 服務有內建，也可自己撰寫。 一個 service 的範例 12345678910export class BookListService { AddBook(book: BookModel) { console. log('added book:'${book}); } EditBook(book: BookModel) { console. warn('edited book:'${book}); } DeleteBook(book: BookModel) { console. error('deleted book:'${book}); }}8. 依賴注入 (Dependency Injection) 因為 DI 本身有太多可以講，故我們這邊就只提到 Service 的 DI。 拿 Service 來說。 123456import { Injectable } from '@angular/core';@Injectable()export class HeroService { constructor() { }}@Injectable()是angular的service使用做依賴注入的裝飾詞，可以使Service成為可被注入的元件。 當我們在provider設定這個服務給這個module使用，如下： 123providers: [ UserService],接著我們就可以在整個專案中從constructor直接宣告這個服務，在所有地方取得的都會是同一個 service。 1234567export class HeroListComponent { heroes: Hero[];  constructor(heroService: HeroService) {  this. heroes = heroService. getHeroes(); }}當然還有很多功能，區區一小篇 blog post 講不完。 就請各位至 Angular 官網慢慢啃食囉~ "
    }, {
    "id": 19,
    "url": "http://localhost:4000/react-vs-angular-part-1/",
    "title": "React 跟 Angular 的框架分析 — Part 1: Angular 跟 React 的快速背景",
    "body": "2020/12/24 - 歡迎來到小孩子才做選擇，我兩個都要！React 跟 Angular 的框架分析系列！ 這篇分析會切成以下四個部分，你現在在這裡： Angular 跟 React 的快速背景快速帶過近幾年兩個框架的發展 trends （更詳細的 trends 分析會另外開一篇）兩個框架的優缺點，每提一點，會附上實作 comparison下集預告：配合後端 + 串起 API 後，誰勝出準備好的話，我們就開始囉~ 關於 Angular 跟 React: 我們先來聊聊 Angular。 Angular，後面有 Google 爸爸撐腰的 JavaScript 框架。 講到了 Angular 就必須聊聊 Angular 的前身： AngularJS AngularJS: 最早之前 Google 在 2010 年創建了 AngularJS （Angular 的前身），學習難度不低，但當時的確引發了很多話題。 它最大賣點是可以透過 &lt;script&gt; 標籤添加到 HTML 頁面，AngularJS 通過這個指令擴展了HTML，並且通過表達式綁定數據到 HTML。 而最大的特性則是：MVC、模塊化、自動化雙向數據綁定、語義化標籤、依賴注入等等。 那為什麼我們要提到 AngularJS 咧？因為大家很容易搞混 AngularJS 跟 Angular 2+。 AngularJS = 2010 年推出的舊框架，明年即將被 Google 冷藏，不再支援。 Angular 2+ （又或是我們在市場常看的 Angular 7, Angular 8… Angular 11 等） = 2016 年才推出的框架，是 AngularJS 的升級版。 記住我們現在常常聽到的 Angular 7/Angular 8/ Angular 9 什麼的其實都是 Angular 2+ (第二代 Angular)，也是我們的主角。 而在這篇文章裡，我如果提到 Angular，就是在說 Angular 2+。 Angular + 特色: Angular 是 2016 年被推出的框架，一樣是 Google 開發的，可是兩者基本上是 Java 跟 JavaScript 的差別，基本上兩個不同的語言。 Angular 採用 JS ES6 來開發，它主要由 8 個部分組成： 模塊 (Modules)組件 (Components)模板 (Templates)元數據 (Metadata)數據綁定 (Data Binding)指令 (Directives)服務 (Services)依賴注入 (Dependency Injection)對這些部分有興趣的客官們，請移駕至這裡：Angular 特色~ 這邊我們就不一一帶過了，畢竟這篇是在講 React 跟 Angular 的快速歷史。 React 部分重整中，待補上。 下集預告：關於市場趨勢…: 兩個前端框架歷史介紹的差不多了，那他們的市場趨勢又是如何呢？ 誰佔上風？誰比較好上手？又是誰默默崛起、誰被誤會？ 我們下次見~ "
    }, {
    "id": 20,
    "url": "http://localhost:4000/react-11/",
    "title": "Build Custom Hooks",
    "body": "2020/12/21 - 短篇 React 學習筆記。 What is React Hooks?: They are functions that let us hooks into React state and lifecycle features from function components. Hooks reduces the complexity of state management. Redux is great for state management, but there are many steps in the process. Rather, hooks can be seen as a singular step. (More on this in a later post~) Why build our own custom hooks? Building our own hooks lets us extract component logic into reusable functions. Sometimes, when we want to share logic between 2 JavaScript functions, we extract it to a third function. Since hooks and components are JS function, we can extract them as well. Building Custom Hooks: A custom Hook is a JavaScript function whose name starts with “use” and that may call other Hooks. Say we want to to see if our friends are online. But we also want to build a contact list that shows us who is online. So we can extract hook logic, and apply the hook into where the application needs the “friend status” logic. Here’s our custom hook that shows if a friend is online: 123456789101112131415161718import { useState, useEffect } from 'react';function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; {  function handleStatusChange(status) {   setIsOnline(status. isOnline);  }  ChatAPI. subscribeToFriendStatus(friendID, handleStatusChange);  return () =&gt; {   ChatAPI. unsubscribeFromFriendStatus(friendID, handleStatusChange);  }; }); return isOnline;}Now, say we want both Friend Status and Contact List to have the “friend status” logic. That would be… 12345678function FriendStatus(props) { const isOnline = useFriendStatus(props. friend. id); if (isOnline === null) {  return 'Loading. . . '; } return isOnline ? 'Online' : 'Offline';}and contact list… 123456789function ContactListItem(props) { const isOnline = useFriendStatus(props. friend. id); return (  &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;   {props. friend. name}  &lt;/li&gt; );}Keep in Mind…  We must use the prefix “use” in front of our hooks, so it doesn’t get confusing.  The states grabbed by hooks are completely isolated from one another. This means they don’t share the same state.  Each call to a Hook gets isolated state. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/react-10/",
    "title": "Conditional Rendering",
    "body": "2020/12/20 - 短篇 React 學習筆記。 Conditional Rendering: Conditional Rendering = make things happen with certain conditions Common ways in React are…  If. . else statement Element variables Ternary operators Logical &amp;&amp; operators Prevent rendering with nullIf…else: 12345if(isLoggedIn) { return &lt;button&gt; Logout &lt;/button&gt;} else { return &lt;button&gt; Login &lt;/button&gt;}Element Variables: 123456789if(isLoggedIn) { Button = &lt;button&gt; Logout &lt;/button&gt;;} else { Button = &lt;button&gt; Login &lt;/button&gt;;}return( &lt;div&gt;{ Button }&lt;/div&gt;);Ternary operators: 1234567&lt;div&gt; {  isLoggedIn ?    &lt;button&gt; Logout &lt;/button&gt; :   &lt;button&gt; Login &lt;/button&gt; }&lt;/div&gt;Logical &amp;&amp; operators: 12345678&lt;div&gt; {  isLoggedIn &amp;&amp; &lt;button&gt; Logout &lt;/button&gt; } {  !isLoggedIn &amp;&amp; &lt;button&gt; Login &lt;/button&gt; }&lt;/div&gt;Prevent rendering with null: 12345if(isLoggedIn) { return &lt;button&gt; Logout &lt;/button&gt;} else { return null;}"
    }, {
    "id": 22,
    "url": "http://localhost:4000/react-09/",
    "title": "Event Handling",
    "body": "2020/12/20 - 短篇 React 學習筆記。 Handling Events: Events are fired when user interacts with the application. Some examples in React are…  onclick onchange onfocus onblurHandling events in React is very similar to handling events in DOM elements. But there are still some differences… Example of event handling in functional component: 1234567891011function FunctionEventHandling() { function handleClick(e){  console. log('I am eating!!'); } return (  &lt;div&gt;   &lt;button onClick={handleClick}&gt;Let's Eat!&lt;/button&gt;  &lt;/div&gt; );}But why is it this: 1&lt;button onClick={handleClick}&gt;Let's Eat!&lt;/button&gt;and not this? 1&lt;button onClick={handleClick()}&gt;Let's Eat!&lt;/button&gt;Bc the event handling function should NOT be called with (). It we call the handler with (), the function will be executed before the button is clicked!! Event handler is a function not a function call! Example of event handling in class component: 1234567891011121314151617181920212223242526class EatingToggle extends React. Component { constructor(props){  super(props);  this. state = {   isEating: true  };  this. handleClick = this. handleClick. bind(this); } handleClick(){  this. setState( state =&gt; {   isEating: !state. isEating  }) } render(){  return (   &lt;div&gt;    &lt;button onClick={this. handleClick}&gt;     {this. state. isEating ? 'I am eating lah!' : 'Nope, not eating'}     &lt;/button&gt;   &lt;/div&gt;  ); }}` "
    }, {
    "id": 23,
    "url": "http://localhost:4000/react-08/",
    "title": "useEffect Hooks",
    "body": "2020/12/19 - 短篇 React 學習筆記。 useEffect Hooks: Use this Hook to tell React what to do when the component needs to perform a task after rendering. Sample: This side effect will execute on every render including when the component has mounted and every time it updates. Let’s use fetch user from an API as an example…: componentDidMount() 12345678useEffect(() =&gt; { // componentDidMount code goes here fetchUserApi(id). then((user) =&gt; {   setUser(user) })}, []);^Bc we passed an empty array as the second parameter, the useEffect hook will only execute once. componentDidUpdate(prevProps) 1234567useEffect(() =&gt; { // ComponentDidUpdate code goes here  fetchUserApi(id). then((user) =&gt; {   setUser(user) })}, [id]);^This effect will execute only once, when component is updated (includes re-rendering). componentWillUnmount() 123456useEffect(() =&gt; { return() =&gt; {  // componentWillUnmount code goes here  setUser(null) }}, []);All Three Combined 12345678910useEffect(() =&gt; { fetchUserApi(id). then((user) =&gt; {   setUser(user) }) return() =&gt; {  setUser(null) }}, [id]);"
    }, {
    "id": 24,
    "url": "http://localhost:4000/react-07/",
    "title": "Component Lifecycle",
    "body": "2020/12/19 - 短篇 React 學習筆記。 現在一大部分已被 useEffect Hook 取代，但是還是很有學習價值。 Component Lifecycle: In each component, React has a lifecycle which you can monitor and manipulate during its 3 main phases.  ComponentWillMount():  Called once in its component’s lifecycle Called before component render() Avoid any asynchronous behavior in this method setState won’t cause a re-renderComponentDidMount():  Called after component render() once Async function can be called here Call setState here for re-renderComponentWillUnmount():  Called right before component is removed from the DOM Performs cleanups here. (i. e. cancel network call)ComponentWillUpdate():  Lets you manipulate component just before receiving new state/props. ComponentDidUpdate():  Called after any rendered HTML has finished loading. "
    }, {
    "id": 25,
    "url": "http://localhost:4000/react-06/",
    "title": "State",
    "body": "2020/12/19 - 短篇 React 學習筆記。 State: What is State Object that holds information that might change over the lifetime of the component. Used to track data from form input, dynamic data and API. Example - Local State: Assignment: 12345678class Welcome extends React. component { constructor(props){  super(props);  this. state = {   name: 'Boop';  } }}We assign the initial state in the constructor. Reading State: 1console. log(this. state. name);Updating State: 12345// wrongthis. state. name = 'Foo';// correctthis. setState({name: 'Foo'});We need to replace the entire state object. Updating State: State updates may be asynchronous and are merged. Take a look: 123456this. state = { count: 0;}this. setState({count: count + 1}); // count: 1this. setState({count: count + 1}); // count: 1It should give you 2 right?No Both the setState count here is enqueued when its value is 0. So what do we do if we want to access previous state? We pass a function in setState that takes the previous state and updates it in a synchronous manner. Like this: 1234567891011121314151617181920212223this. state = { count: 0;}this. setState( (prevState) =&gt; {  return {   count: prevState. count + 1  } });// count: 1this. setState( (prevState) =&gt; {  return {   count: prevState. count + 1  } });// count: 2useState Hooks (React 16. 8): **To be further discussed in details in a separate post Example code with functional component: 12345678910111213import React, { useState } from 'react';export default function Welcome () { const [count, useCount] = useState(0); return (  &lt;div&gt;   Counter: { count } &lt;br /&gt;   &lt;button onClick={()=&gt; useCount( count + 1 )}&gt;   Add Count&lt;/button&gt;  &lt;/div&gt; );}Note:Hooks aren’t supported in class comp. "
    }, {
    "id": 26,
    "url": "http://localhost:4000/react-05/",
    "title": "Functional Components vs Class Components",
    "body": "2020/12/18 - 短篇 React 學習筆記。 About Components: Core building blocks of React. Multiple individual components forms a parent component. 2 types of components in React:  Functional Class Before React Hooks were introduced, functional components were generally used for style (aka the dumb/stateless/presentational component) and class components were used for logic (smart component/stateful/container components). This practice has since been deprecated. Functional Components: After React Hooks are introduced, functional components are used to store state using react hooks. Like the name implies, think of functional component as a function. Example: 123function Welcome(props) {return &lt;h1&gt;Hello, {props. name} &lt;/h1&gt;;}1const element = &lt;Welcome name= Boop  /&gt; Props should never be modified! When should you use functional components?: For React &lt; 16. 8…  When your comp. simply receive props, doesn’t have a state and renders smth (dumb/stateless/presentational comp. )For React &gt; 16. 8… (React Hooks were introduced)  Func. comp. can now have its own state via React Hooks Preferred over class comp. bc of React Hooks now. Class Components: Class components were preferred before React Hooks were introduced. Basically ES6 classes. Similar to functional component, class comp. optionally receives props as input and renders JSX. Class comp. can also maintain private internal state of a particular comp. Example: 12345class Welcome extends React. Component { render(){  return &lt;h1&gt;Hello, {this. props. name} &lt;/h1&gt;; }}Comp. should always start with capital letter. Again, props should never be modified! Drawbacks:  Class comp. is slower than fun. comp in terms of performance. This difference increases as the number of comp in the app increases.  Slightly inefficient to use bc it requires more coding. "
    }, {
    "id": 27,
    "url": "http://localhost:4000/react-04/",
    "title": "Virtual DOM & DOM Manipulation",
    "body": "2020/12/18 - 短篇 React 學習筆記。 Virtual DOM: React creates a tree of custom objects, each representing a part of the DOM. If we create a p element inside a div, React will create React. div object and React. p object. React will then modify these objects quickly when needed (modifying only what’s required) rather than changing the real DOM. Before it renders the component, React will determine what needs to be changed using the virtual DOM. Then React will get virtual DOM and real DOM in sync. Virtual DOM = blueprint Virtual DOM contains the required details needed to construct the DOM. But it doesn’t require all the heavy parts of the real DOM. Thus, making virtual DOM creation much faster than actual DOM. DOM Manipulation: DOM Manipulation = dynamically changing the content of web page. Reconciliation = changes made to the virtual DOM and then sync to the real DOM. Diffing = process when React figures out which objects has been changed Process:  React updates virtual DOM States of virtual DOM will be compared (previous + updated), to identify what has been changed. This is done via Diffing Algorithm.  Changed objects will get updated to the real DOMExample of Diffing Algorithm: When root is changed, React will delete the tree and rebuild the entire tree. 12345// old&lt;div&gt;&lt;App /&gt;&lt;/div&gt;// new&lt;span&gt;&lt;App /&gt;&lt;/span&gt;When attribute is changed, React will only change the attribute. 12345// old&lt;div id= root &gt;&lt;/div&gt;// new&lt;div id= boop &gt;&lt;/div&gt;When new child element is added at the end of a list, React will simply add it to the list. 123456789101112// old&lt;ul&gt; &lt;li&gt;hi&lt;/li&gt; &lt;li&gt;hi1&lt;/li&gt;&lt;/ul&gt;// new&lt;ul&gt; &lt;li&gt;hi&lt;/li&gt; &lt;li&gt;hi1&lt;/li&gt; &lt;li&gt;hi2&lt;/li&gt;&lt;/ul&gt;"
    }, {
    "id": 28,
    "url": "http://localhost:4000/react-03/",
    "title": "JSX",
    "body": "2020/12/18 - 短篇 React 學習筆記。 JSX: JSX = JavaScript Syntax Extension Lets XML/HTML + JavaScript/React code coexist. Example: 12345const name = 'Boop';const element = '&lt;div&gt;Hello, {name}&lt;/div&gt;';ReactDOM. render(element, document. getElementById('root'));In this example, the variable name is wrapped in JSX. These code are then converted into standard JavaScript objects that can be parsed by the JS Engine. Why JSX?:  Much faster than normal JS, as JSX optimizes when it’s converted into regular JS.  Easy to create template.  React Component lets us keep both markup and logic together in one file using JSX. Attributes in JSX: React DOM uses camelCase. For example, class becomes className… 1let button = &lt;button className= btn-primary &gt;Button&lt;/button&gt;;"
    }, {
    "id": 29,
    "url": "http://localhost:4000/react-02/",
    "title": "ES6",
    "body": "2020/12/17 - 短篇 React 學習筆記。 ES6 for React: JavaScript = a “dialect” of ECMAScript ES6 = ECMAScript 2015 = JavaScript standard. React uses ES6. ES6 is also getting popularity for writing server applications and services via Node. js. Variables: In ES6, variables are declared using const, let and var keywords. We cannot redeclare const or let variables. And, we can only reassign let variable. Block Scope vs Function Scope: var is function scoped. It can be accessed everywhere. let is a block scoped. It can only be accessed inside the block where it is defined. New Update: Arrow Function &amp; Regular Function: Regular Function 123var hello = function(name) {  return name}ES6 Arrow function 1let hello = (name) =&gt; { return name }Even more ways to define arrow functions… We can omit {}, if there’s only one expression 1let hello = (num1, num2) =&gt; num1 + num2;We can omit (), if there’s only one argument 1let hello = name =&gt; name;We can use _, if there’s no argument 1let hello = _ =&gt; 1 + 2;this keyword: In regular function, the this keyword represents the object called inside a function. In arrow function, the this keyword represents the object that defined the function, which is the window. object. Template Literals: Quoted between ``, string literals that can include expressions. Like this… 12let name = 'Boop';let greeting = `Hello, ${name}`;Destructuring: Arrays: 12let array = [1,2,3,4,5];let [value1,value2,value3] = array;this is equivalent to 1234let array = [1,2,3,4,5];let value1 = array[0];let value2 = array[1];let value3 = array[2];Destructuring: Objects: Similar to destructuring array… 123456let obj = { key1: 'boop', key2: 'foo', key3: 'bar'};let [key1,key2,key3] = obj;Spread Operator: The spread operator spreads the values in an iterable, such as array &amp; strings, across arguments or elements. 123456let fruits = ['apples','bananas','strawberry'];let veggies = ['cabbage','asparagus','green onions'];let grocery = [. . . fruits,. . . veggies];console. log(grocery);// ['apples','bananas','strawberry','cabbage','asparagus','green onions']Spread operator can also be used to clone an array &amp; objects in an arrow function. 123456const dog1 = { name: 'Boop', breed: 'Corgi'}const dog2 = {. . . dog1}Rest Parameter: This is used to pass an arbitrary number of argument, and to process these args within the arrow function. Rest parameters are array instances. We use rest parameters if we need extra parameters other than the specified ones. 1234567let foo = function(a, b, . . . args) { console. log(args);}foo(1,2); // [], nothing will print inside the array, because we don't have extra parametersfoo(1,2,3,4,5) // [3,4,5]Difference between rest parameter and normal arguments Rest parameters returns an array by default, so methods like map, sort, shift, forEach… can be used directly. But for normal args, they need to be converted into an array because normal args are objects. "
    }, {
    "id": 30,
    "url": "http://localhost:4000/react-01/",
    "title": "Intro to React",
    "body": "2020/12/17 - 短篇 React 學習筆記。 Intro to React: React = JS library for building user interfaces or UI components. Features:  JSX - JavaScript Syntax Extension Virtual DOM One way data binding Extensions DebuggingAdvantages &amp; Limitations: Virtual DOM: React uses virtual DOM which is a JS object. This will improve apps performance, since JS virtual DOM is faster than regular DOM. Usability:React can be used on client and server sides as well as with other frameworks (i. e. NativeScript). Maintenance:Component and data patterns improve readability, which helps to maintain larger apps. But React covers only the view part of the app. So to complete the entire development we would have to choose other technologies. "
    }, {
    "id": 31,
    "url": "http://localhost:4000/hello-native-script/",
    "title": "前端也可以寫手機 app ? 神奇的框架: NativeScript",
    "body": "2020/12/11 - 「魔鏡啊，魔鏡，什麼東西可以讓我寫一次就產生蘋果和安卓的 app？」 「…哈囉？魔鏡？」 呃，好，不玩了，我們直接進主題。 首先，我們先來聊聊前端跟手機 app 這個話題: 這個 section 廢話很多，歡迎你跳過 在人人一台手機，以及只會寫 static site 就直接被淘汰的年代（哈囉，2004!），我們前端每年也有越來越多好玩的新玩具，任君挑選。 是的，華生，在前端框架年年出、年年更新的盛況下，現在前端寫的已經不是靜態網站了，我們基本上都在寫 web app ，配合可愛的後端隊友，一個個網頁版的 start up 服務就這樣被孵化出來。 那網頁版的都出來了，為什麼不寫手機 app 呢？ 呃，因為我是前端我不會（喂 因為寫手機 app 真的是個學問，每個平台都有自己的寫法、規範，除此之外還得學習不同的語言才寫的出來，寫的出來還只是基礎，還要畫面好看、功能好用、效能夠快。 喔，對了，還要 UI/UX 好用哦，啾咪。 不過，話說回來，各種 app 不就是這樣嘛，哈哈。 BUT，沒錯，就是這個 BUT 他出現了，我是前端就不能寫手機 app 嘛？ 我也想寫啊，可是因為（以下省略幾十行理由）我無法。 沒關係，這時候我們的心聲被聽到了（耶~ 我們現在有種神奇的科技，主張只要寫一次 code 就可以產出雙平台 apps，那就是 hybrid apps！ 關於 hybrid apps ，我們之後會細說，我們先來聊聊今天的主角（也是 hybrid apps 之一的）: NativeScript! 原理: 所以 NativeScript 到底是什麼東東？ 以下為了方便起見，我會直接將 Native Script 縮寫成 NS。 簡單來說，它就是個可以寫原生 iOS 跟 Android app 的 JavaScript Framework。 它不僅是 Open Source，也有著偉大的理想，就是讓工程師可以寫一次，就哪裡（ iOS + Android ）都可以用的框架（當然這是夢想，跟實際還是有很大的差別，不過夠接近了啦~） 那我們需要會什麼語言才能寫它咧？ NS 的好處是它有多種寫法可以選擇，前端三大框架霸主都可以：  React Angular Vue那泥，你不會？不想寫？ 沒關係，它還可以用最單純寫法：  Vanilla JavaScript TypeScript然後，重頭戲來了！ NS 最大特點就是可以存取原生（Native） iOS 跟 Android 的 classes！ 可是為什麼他可以寫原生 app，他不是用 JavaScript嗎？而 Native 又是什麼鬼？ 這個跟 NS 的結構有關，我們往下看。 結構: 所以他到底是怎麼讓雙平台 apps 跑起來的 &amp; 他到底用了什麼? 我們先來看看這個圖: NS 是用了來自 Google 的 JavaScript V8 virtual machine、Runtime &amp; bridge module 組建而成。 那他們都在幹嘛咧？我們快速看一下圖，對照下面的工作列表：  Virtual machine 負責翻譯 + 執行 JS code Bridge Module 負責翻譯呼叫原生手機的 API call，並把結果回傳， NS Runtimes 讓你可以用 JavaScript 呼叫 Android 跟 iOS 框架的 API NS Core modules 會幫你創建個 API ，把你的 JS 程式碼翻譯成原生平台可用的程式碼 NativeScript CLI 就是你要寫 app 的平台 NativeScript 插件（{N} Plugins），是整個 NS 的核心簡單來說：因為可以使用 API call 就能操控手機功能，所以 NS 可以讓你直接用 JavaScript （不需要會 Objective-C 或 Java ）寫出手機 app。 它可以讓你直接用 JS 就可以寫手機才有的功能！（就好比拍照啦、查看聯絡人啦、打電話…etc） 那我們能怎麼寫呢？: 說到這，可能很多朋友不確定 NS 是不是適合自己。 沒關係，我們有個試水溫的好方法，那就是 NS 官方推出的線上 Web IDE - NativeScript Playground！ NS Playground 只要下載官方推出的兩個 app， preview 跟 playground 即可線上編寫手機 app ，live 測試（很酷吧！ 而試水溫過，覺得 NS 好像還可以，就可以直接下載 Local Machine CLI 寫起來！ Full Setup Guide 因為 setup 太繁雜，就不帶大家一步步過了，請自行移步樓上鏈接處理 setup。 講完了 setup，我們接著來看看 NS 是怎麼產生 UI Layout 的。 NativeScript 的 UI Layout: 我們先看這張圖： NS 其實有一套類似 XML 的 UI 寫法，拿大家最熟悉的按鈕來說，一個按鈕就是: 1&lt;Button (tap)= onTap()  class= btn-primary  /&gt;再配合 CSS、 ScSS 的結合，就可以把 UI 繪製出來！ 可是，我們總不可能整個 app 都要自己寫吧？ 對，這個時候我們就要開始來聊聊 NS 的缺點，跟如何找資源了（抱大神大腿 NativeScript 插件 （主要結構之一）: 之前稍稍提到的 NS 本身也是靠插件堆起來的，包括主要核心 NativeScript Core，那 NS 官方的工程師有沒有釋放出資源給我們用呢？ 要說有嗎，其實並沒有，很多東西都得自己手寫，但是還是有啦。 我們的 NS MarketPlace ( NS 市集 ) 可是 NativeScript 實在是太冷門了，所以很多東西都沒有 up to date，都得自己創建，但還是有差不多 1563 個插件。 不過 2014 年被創建後，只有 16 個是被官方認證的插件，而半年內有更新的插件也只有 71 個。 嗯哼，你沒看錯，我們來聊聊 NS 的缺點吧。 NativeScript &amp; Hybrid Apps 缺點: 在開始前，我們先說說 Native vs Hybrid Apps。 我們看這個圖： Native Apps = 原生語言程式寫的 app，就是所謂的用 Java 寫的 Android app 或 Objective-C/Swift 寫的 iOS app。 Hybrid Apps = 混合語言程式寫的 app，就是前端三寶 (HTML/CSS/JS) 寫的，寫好的這些 code 會被裝進原生容器 (Native Container) ，透過手機上的瀏覽器引擎來呈現和執行 但是，其實 hybrid apps 跟實際 native apps 開發還是有差別的！ 為什麼? 因為 NS、React Native 這些 hybrid apps 相較於 native apps，還是有做不到的 10-20%。拿 React Native 來說，就是那些在 Facebook 的工程師不願意寫出來的那些複雜功能。（請去追殺這群傢伙 接著，我們來說 hybrid app 的性能 Hybrid Apps 依靠手機的瀏覽器速度 (假設我們用 Ionic 這個框架)，也就表示它基本上不可能像 native apps 那麼快。 那這和 NS 有什麼關係？ 因為 NS 也是 hybrid apps，所以它啟動的 loading 時間，基本上就是等待 Windows 95 電腦啟動，功能也是，而且 app 越大越慢。 非常小的討論社群 剛剛在講 plugins 的時候有提到。 NS 剛出來時，已經被大多數想寫 mobile 的工程師淘汰（那時 React &amp; React Native 都崛起啊，加上 NS 又複雜，當時也不支援 React… 所以基本上想寫 hybrid apps 都跑去寫 React Native，NS 根本沒人寫。 Hybrid Apps 框架大亂鬥: 這是之前研究框架是搜集出來的結果，不用一個字一個字查。 我直接以因為專案需求使用 NS 的主要工程師角色，很負責的用一句話帶過：珍惜生命，遠離 NativeScript。 好啦，也不能這麼混，我還是總結一下這個表單： 社團小、開發者也少、開發難度也不低，很多東西要自己寫 那，一直提到的社團小、開發者也少、開發難度也不低，NativeScript 到底有什麼能贏的過其他兩位的呢？ 第一點 Access to Native API。 NS 最大的賣點就是他可以直接呼叫 API，讓我們用寫 JS 的方法寫手機 app ，做到打電話、拍照、查看聯絡人的功能，可是 React Native 也可以啊，React Native 有 Native Module 不是嗎？ 對，可是相較於 Ionic 的話，NS 還是佔上風的，因為 Ionic 不支援手機 Native 的功能。 好吧，那這樣我們用 React Native，不就好了嗎？ 我們來看看第二點，不限制於 React 記得最開始我們有講到嗎？ NS 有5種不同的寫法，不會 React 還是可以寫！ NS 可以寫 Angular、Vue、React、JavaScript &amp; TypeScript （而我這個目前還在啃食 React 資訊、又因公司專案需求的工程師就這樣入了 NS 的坑） 那重點來了… Native Script 的缺點那麼多，為什麼我還會從零學起，並用 NativeScript 寫手機 app 呢？ 嗯，很簡單。 因為客戶要求。  其實，我還想私心跟大家 demo 一下 NS 的功能，可是礙於公司產品不可以 showcase，我之後再奉上一小段其他 side project app 的迷你 demo 吧， 請敬請期待。 謝謝各位的閱讀。 References: https://dev. to/ronakpatel70/nativescript-v-s-react-native-what-to-choose-for-cross-platform-app-development-d20https://tylerablake. github. io/nativescript-intro/https://buzzorange. com/techorange/2013/11/28/native-app-or-hybrid/https://insights. daffodilsw. com/blog/nativescript-vs-react-native-overview-and-comparisonhttps://blog. jscrambler. com/react-native-vs-ionic-vs-nativescript-a-practical-guide/https://blog. jscrambler. com/introduction-to-nativescript/https://www. quora. com/What-are-the-bad-sides-if-I-build-an-app-for-iOS-and-Android-using-NativeScript-and-Angular-compared-to-native-appshttps://nativescript. org/faq/how-does-nativescript-work/https://www. quora. com/Has-anyone-built-a-project-with-NativeScript-or-React-Native-and-which-seems-to-have-the-upper-handhttps://www. quora. com/Should-I-explore-iOS-development-along-with-my-hybrid-knowledge-and-experience-with-Angular-Ionic-and-NativeScript-Will-it-be-worth-my-timehttps://www. itread01. com/content/1544417462. html "
    }, {
    "id": 32,
    "url": "http://localhost:4000/hello-react/",
    "title": "今年黑五不購物，讀書去~",
    "body": "2020/11/25 - 那個去年黑五在打LoL、吃牛排的 Angular 工程師，今年怎麼開始學 React. js 啦？ 今年黑五不購物，讀書去~: 如題，去年的黑五我在打LoL、吃牛排，今年的我，不一樣了！我讀書。 我是一個平凡的 Angular 工程師，直到在誠品看到了一本 React. js 的教學書。於是，我變成了一個，會一點點 React. js 的前端工程師。 這週的星期五就是黑色星期五了，黑色星期五想必是要大大的購物一番，不過，因為我買到了這本書，我便一頭栽進去 React. js 的世界。 今年的黑五，都在看書和寫扣。 在這一週，我學會了 + 花費時間: 這一週每天約花五個小時念這本書，因為我的中文程度只有小學四年級。所以我需要花費大量時間理解 Concept，轉成英文確保自己理解後，再繼續實作。 於是他變成了這樣： 接下來的週末兩天，星期五花了 7 小時，星期六花了 5 小時，於是，新版的履歷就生出來囉！ 之前我的履歷長這樣 現在的履歷，登登！ RWD 也沒有問題！ 使用技術：React. js, React Hooks 欸，對，他上線了，在這裡: resume "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});